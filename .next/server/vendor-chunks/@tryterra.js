"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tryterra";
exports.ids = ["vendor-chunks/@tryterra"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tryterra/terra-ui/dist/cjs/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tryterra/terra-ui/dist/cjs/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nvar react = {exports: {}};\n\nvar react_production_min = {};\n\n/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredReact_production_min;\n\nfunction requireReact_production_min () {\n\tif (hasRequiredReact_production_min) return react_production_min;\n\thasRequiredReact_production_min = 1;\nvar l=Symbol.for(\"react.element\"),n=Symbol.for(\"react.portal\"),p=Symbol.for(\"react.fragment\"),q=Symbol.for(\"react.strict_mode\"),r=Symbol.for(\"react.profiler\"),t=Symbol.for(\"react.provider\"),u=Symbol.for(\"react.context\"),v=Symbol.for(\"react.forward_ref\"),w=Symbol.for(\"react.suspense\"),x=Symbol.for(\"react.memo\"),y=Symbol.for(\"react.lazy\"),z=Symbol.iterator;function A(a){if(null===a||\"object\"!==typeof a)return null;a=z&&a[z]||a[\"@@iterator\"];return \"function\"===typeof a?a:null}\n\tvar B={isMounted:function(){return !1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B;}E.prototype.isReactComponent={};\n\tE.prototype.setState=function(a,b){if(\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a)throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");this.updater.enqueueSetState(this,a,b,\"setState\");};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\");};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B;}var H=G.prototype=new F;\n\tH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\n\tfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=\"\"+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f;}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return {$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\n\tfunction N(a,b){return {$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return \"object\"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return \"$\"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return \"object\"===typeof a&&null!==a&&null!=a.key?escape(\"\"+a.key):b.toString(36)}\n\tfunction R(a,b,e,d,c){var k=typeof a;if(\"undefined\"===k||\"boolean\"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case \"string\":case \"number\":h=!0;break;case \"object\":switch(a.$$typeof){case l:case n:h=!0;}}if(h)return h=a,c=c(h),a=\"\"===d?\".\"+Q(h,0):d,I(c)?(e=\"\",null!=a&&(e=a.replace(P,\"$&/\")+\"/\"),R(c,b,e,\"\",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?\"\":(\"\"+c.key).replace(P,\"$&/\")+\"/\")+a)),b.push(c)),1;h=0;d=\"\"===d?\".\":d+\":\";if(I(a))for(var g=0;g<a.length;g++){k=\n\ta[g];var f=d+Q(k,g);h+=R(k,b,e,f,c);}else if(f=A(a),\"function\"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if(\"object\"===k)throw b=String(a),Error(\"Objects are not valid as a React child (found: \"+(\"[object Object]\"===b?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":b)+\"). If you meant to render a collection of children, use an array instead.\");return h}\n\tfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,\"\",\"\",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b;},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b;});-1===a._status&&(a._status=0,a._result=b);}if(1===a._status)return a._result.default;throw a._result;}\n\tvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};react_production_min.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments);},e);},count:function(a){var b=0;S(a,function(){b++;});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error(\"React.Children.only expected to receive a single React element child.\");return a}};react_production_min.Component=E;react_production_min.Fragment=p;\n\treact_production_min.Profiler=r;react_production_min.PureComponent=G;react_production_min.StrictMode=q;react_production_min.Suspense=w;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\n\treact_production_min.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \"+a+\".\");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=\"\"+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f]);}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\n\tfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g;}return {$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};react_production_min.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};react_production_min.createElement=M;react_production_min.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};react_production_min.createRef=function(){return {current:null}};\n\treact_production_min.forwardRef=function(a){return {$$typeof:v,render:a}};react_production_min.isValidElement=O;react_production_min.lazy=function(a){return {$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};react_production_min.memo=function(a,b){return {$$typeof:x,type:a,compare:void 0===b?null:b}};react_production_min.startTransition=function(a){var b=V.transition;V.transition={};try{a();}finally{V.transition=b;}};react_production_min.unstable_act=function(){throw Error(\"act(...) is not supported in production builds of React.\");};\n\treact_production_min.useCallback=function(a,b){return U.current.useCallback(a,b)};react_production_min.useContext=function(a){return U.current.useContext(a)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(a){return U.current.useDeferredValue(a)};react_production_min.useEffect=function(a,b){return U.current.useEffect(a,b)};react_production_min.useId=function(){return U.current.useId()};react_production_min.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\n\treact_production_min.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};react_production_min.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};react_production_min.useMemo=function(a,b){return U.current.useMemo(a,b)};react_production_min.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};react_production_min.useRef=function(a){return U.current.useRef(a)};react_production_min.useState=function(a){return U.current.useState(a)};react_production_min.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\n\treact_production_min.useTransition=function(){return U.current.useTransition()};react_production_min.version=\"18.2.0\";\n\treturn react_production_min;\n}\n\nvar react_development = {exports: {}};\n\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nreact_development.exports;\n\nvar hasRequiredReact_development;\n\nfunction requireReact_development () {\n\tif (hasRequiredReact_development) return react_development.exports;\n\thasRequiredReact_development = 1;\n\t(function (module, exports) {\n\n\t\tif (true) {\n\t\t  (function() {\n\n\t\t/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\t\tif (\n\t\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n\t\t    'function'\n\t\t) {\n\t\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t\t}\n\t\t          var ReactVersion = '18.2.0';\n\n\t\t// ATTENTION\n\t\t// When adding new symbols to this file,\n\t\t// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\t\t// The Symbol used to tag the ReactElement-like types.\n\t\tvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\n\t\tvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\n\t\tvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n\t\tvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n\t\tvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n\t\tvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\n\t\tvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\n\t\tvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n\t\tvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n\t\tvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n\t\tvar REACT_MEMO_TYPE = Symbol.for('react.memo');\n\t\tvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\n\t\tvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n\t\tvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n\t\tvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\tfunction getIteratorFn(maybeIterable) {\n\t\t  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n\t\t    return null;\n\t\t  }\n\n\t\t  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n\t\t  if (typeof maybeIterator === 'function') {\n\t\t    return maybeIterator;\n\t\t  }\n\n\t\t  return null;\n\t\t}\n\n\t\t/**\n\t\t * Keeps track of the current dispatcher.\n\t\t */\n\t\tvar ReactCurrentDispatcher = {\n\t\t  /**\n\t\t   * @internal\n\t\t   * @type {ReactComponent}\n\t\t   */\n\t\t  current: null\n\t\t};\n\n\t\t/**\n\t\t * Keeps track of the current batch's configuration such as how long an update\n\t\t * should suspend for if it needs to.\n\t\t */\n\t\tvar ReactCurrentBatchConfig = {\n\t\t  transition: null\n\t\t};\n\n\t\tvar ReactCurrentActQueue = {\n\t\t  current: null,\n\t\t  // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n\t\t  isBatchingLegacy: false,\n\t\t  didScheduleLegacyUpdate: false\n\t\t};\n\n\t\t/**\n\t\t * Keeps track of the current owner.\n\t\t *\n\t\t * The current owner is the component who should own any components that are\n\t\t * currently being constructed.\n\t\t */\n\t\tvar ReactCurrentOwner = {\n\t\t  /**\n\t\t   * @internal\n\t\t   * @type {ReactComponent}\n\t\t   */\n\t\t  current: null\n\t\t};\n\n\t\tvar ReactDebugCurrentFrame = {};\n\t\tvar currentExtraStackFrame = null;\n\t\tfunction setExtraStackFrame(stack) {\n\t\t  {\n\t\t    currentExtraStackFrame = stack;\n\t\t  }\n\t\t}\n\n\t\t{\n\t\t  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n\t\t    {\n\t\t      currentExtraStackFrame = stack;\n\t\t    }\n\t\t  }; // Stack implementation injected by the current renderer.\n\n\n\t\t  ReactDebugCurrentFrame.getCurrentStack = null;\n\n\t\t  ReactDebugCurrentFrame.getStackAddendum = function () {\n\t\t    var stack = ''; // Add an extra top frame while an element is being validated\n\n\t\t    if (currentExtraStackFrame) {\n\t\t      stack += currentExtraStackFrame;\n\t\t    } // Delegate to the injected renderer-specific implementation\n\n\n\t\t    var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n\t\t    if (impl) {\n\t\t      stack += impl() || '';\n\t\t    }\n\n\t\t    return stack;\n\t\t  };\n\t\t}\n\n\t\t// -----------------------------------------------------------------------------\n\n\t\tvar enableScopeAPI = false; // Experimental Create Event Handle API.\n\t\tvar enableCacheElement = false;\n\t\tvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n\t\tvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n\t\t// stuff. Intended to enable React core members to more easily debug scheduling\n\t\t// issues in DEV builds.\n\n\t\tvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n\t\tvar ReactSharedInternals = {\n\t\t  ReactCurrentDispatcher: ReactCurrentDispatcher,\n\t\t  ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n\t\t  ReactCurrentOwner: ReactCurrentOwner\n\t\t};\n\n\t\t{\n\t\t  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n\t\t  ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n\t\t}\n\n\t\t// by calls to these methods by a Babel plugin.\n\t\t//\n\t\t// In PROD (or in packages without access to React internals),\n\t\t// they are left as they are instead.\n\n\t\tfunction warn(format) {\n\t\t  {\n\t\t    {\n\t\t      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t        args[_key - 1] = arguments[_key];\n\t\t      }\n\n\t\t      printWarning('warn', format, args);\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction error(format) {\n\t\t  {\n\t\t    {\n\t\t      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t\t        args[_key2 - 1] = arguments[_key2];\n\t\t      }\n\n\t\t      printWarning('error', format, args);\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction printWarning(level, format, args) {\n\t\t  // When changing this logic, you might want to also\n\t\t  // update consoleWithStackDev.www.js as well.\n\t\t  {\n\t\t    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\t\t    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n\t\t    if (stack !== '') {\n\t\t      format += '%s';\n\t\t      args = args.concat([stack]);\n\t\t    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n\t\t    var argsWithFormat = args.map(function (item) {\n\t\t      return String(item);\n\t\t    }); // Careful: RN currently depends on this prefix\n\n\t\t    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n\t\t    // breaks IE9: https://github.com/facebook/react/issues/13610\n\t\t    // eslint-disable-next-line react-internal/no-production-logging\n\n\t\t    Function.prototype.apply.call(console[level], console, argsWithFormat);\n\t\t  }\n\t\t}\n\n\t\tvar didWarnStateUpdateForUnmountedComponent = {};\n\n\t\tfunction warnNoop(publicInstance, callerName) {\n\t\t  {\n\t\t    var _constructor = publicInstance.constructor;\n\t\t    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n\t\t    var warningKey = componentName + \".\" + callerName;\n\n\t\t    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n\t\t      return;\n\t\t    }\n\n\t\t    error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n\n\t\t    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n\t\t  }\n\t\t}\n\t\t/**\n\t\t * This is the abstract API for an update queue.\n\t\t */\n\n\n\t\tvar ReactNoopUpdateQueue = {\n\t\t  /**\n\t\t   * Checks whether or not this composite component is mounted.\n\t\t   * @param {ReactClass} publicInstance The instance we want to test.\n\t\t   * @return {boolean} True if mounted, false otherwise.\n\t\t   * @protected\n\t\t   * @final\n\t\t   */\n\t\t  isMounted: function (publicInstance) {\n\t\t    return false;\n\t\t  },\n\n\t\t  /**\n\t\t   * Forces an update. This should only be invoked when it is known with\n\t\t   * certainty that we are **not** in a DOM transaction.\n\t\t   *\n\t\t   * You may want to call this when you know that some deeper aspect of the\n\t\t   * component's state has changed but `setState` was not called.\n\t\t   *\n\t\t   * This will not invoke `shouldComponentUpdate`, but it will invoke\n\t\t   * `componentWillUpdate` and `componentDidUpdate`.\n\t\t   *\n\t\t   * @param {ReactClass} publicInstance The instance that should rerender.\n\t\t   * @param {?function} callback Called after component is updated.\n\t\t   * @param {?string} callerName name of the calling function in the public API.\n\t\t   * @internal\n\t\t   */\n\t\t  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n\t\t    warnNoop(publicInstance, 'forceUpdate');\n\t\t  },\n\n\t\t  /**\n\t\t   * Replaces all of the state. Always use this or `setState` to mutate state.\n\t\t   * You should treat `this.state` as immutable.\n\t\t   *\n\t\t   * There is no guarantee that `this.state` will be immediately updated, so\n\t\t   * accessing `this.state` after calling this method may return the old value.\n\t\t   *\n\t\t   * @param {ReactClass} publicInstance The instance that should rerender.\n\t\t   * @param {object} completeState Next state.\n\t\t   * @param {?function} callback Called after component is updated.\n\t\t   * @param {?string} callerName name of the calling function in the public API.\n\t\t   * @internal\n\t\t   */\n\t\t  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n\t\t    warnNoop(publicInstance, 'replaceState');\n\t\t  },\n\n\t\t  /**\n\t\t   * Sets a subset of the state. This only exists because _pendingState is\n\t\t   * internal. This provides a merging strategy that is not available to deep\n\t\t   * properties which is confusing. TODO: Expose pendingState or don't use it\n\t\t   * during the merge.\n\t\t   *\n\t\t   * @param {ReactClass} publicInstance The instance that should rerender.\n\t\t   * @param {object} partialState Next partial state to be merged with state.\n\t\t   * @param {?function} callback Called after component is updated.\n\t\t   * @param {?string} Name of the calling function in the public API.\n\t\t   * @internal\n\t\t   */\n\t\t  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n\t\t    warnNoop(publicInstance, 'setState');\n\t\t  }\n\t\t};\n\n\t\tvar assign = Object.assign;\n\n\t\tvar emptyObject = {};\n\n\t\t{\n\t\t  Object.freeze(emptyObject);\n\t\t}\n\t\t/**\n\t\t * Base class helpers for the updating state of a component.\n\t\t */\n\n\n\t\tfunction Component(props, context, updater) {\n\t\t  this.props = props;\n\t\t  this.context = context; // If a component has string refs, we will assign a different object later.\n\n\t\t  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n\t\t  // renderer.\n\n\t\t  this.updater = updater || ReactNoopUpdateQueue;\n\t\t}\n\n\t\tComponent.prototype.isReactComponent = {};\n\t\t/**\n\t\t * Sets a subset of the state. Always use this to mutate\n\t\t * state. You should treat `this.state` as immutable.\n\t\t *\n\t\t * There is no guarantee that `this.state` will be immediately updated, so\n\t\t * accessing `this.state` after calling this method may return the old value.\n\t\t *\n\t\t * There is no guarantee that calls to `setState` will run synchronously,\n\t\t * as they may eventually be batched together.  You can provide an optional\n\t\t * callback that will be executed when the call to setState is actually\n\t\t * completed.\n\t\t *\n\t\t * When a function is provided to setState, it will be called at some point in\n\t\t * the future (not synchronously). It will be called with the up to date\n\t\t * component arguments (state, props, context). These values can be different\n\t\t * from this.* because your function may be called after receiveProps but before\n\t\t * shouldComponentUpdate, and this new state, props, and context will not yet be\n\t\t * assigned to this.\n\t\t *\n\t\t * @param {object|function} partialState Next partial state or function to\n\t\t *        produce next partial state to be merged with current state.\n\t\t * @param {?function} callback Called after state is updated.\n\t\t * @final\n\t\t * @protected\n\t\t */\n\n\t\tComponent.prototype.setState = function (partialState, callback) {\n\t\t  if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n\t\t    throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n\t\t  }\n\n\t\t  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n\t\t};\n\t\t/**\n\t\t * Forces an update. This should only be invoked when it is known with\n\t\t * certainty that we are **not** in a DOM transaction.\n\t\t *\n\t\t * You may want to call this when you know that some deeper aspect of the\n\t\t * component's state has changed but `setState` was not called.\n\t\t *\n\t\t * This will not invoke `shouldComponentUpdate`, but it will invoke\n\t\t * `componentWillUpdate` and `componentDidUpdate`.\n\t\t *\n\t\t * @param {?function} callback Called after update is complete.\n\t\t * @final\n\t\t * @protected\n\t\t */\n\n\n\t\tComponent.prototype.forceUpdate = function (callback) {\n\t\t  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n\t\t};\n\t\t/**\n\t\t * Deprecated APIs. These APIs used to exist on classic React classes but since\n\t\t * we would like to deprecate them, we're not going to move them over to this\n\t\t * modern base class. Instead, we define a getter that warns if it's accessed.\n\t\t */\n\n\n\t\t{\n\t\t  var deprecatedAPIs = {\n\t\t    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n\t\t    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n\t\t  };\n\n\t\t  var defineDeprecationWarning = function (methodName, info) {\n\t\t    Object.defineProperty(Component.prototype, methodName, {\n\t\t      get: function () {\n\t\t        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n\n\t\t        return undefined;\n\t\t      }\n\t\t    });\n\t\t  };\n\n\t\t  for (var fnName in deprecatedAPIs) {\n\t\t    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n\t\t      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction ComponentDummy() {}\n\n\t\tComponentDummy.prototype = Component.prototype;\n\t\t/**\n\t\t * Convenience component with default shallow equality check for sCU.\n\t\t */\n\n\t\tfunction PureComponent(props, context, updater) {\n\t\t  this.props = props;\n\t\t  this.context = context; // If a component has string refs, we will assign a different object later.\n\n\t\t  this.refs = emptyObject;\n\t\t  this.updater = updater || ReactNoopUpdateQueue;\n\t\t}\n\n\t\tvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n\t\tpureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n\t\tassign(pureComponentPrototype, Component.prototype);\n\t\tpureComponentPrototype.isPureReactComponent = true;\n\n\t\t// an immutable object with a single mutable value\n\t\tfunction createRef() {\n\t\t  var refObject = {\n\t\t    current: null\n\t\t  };\n\n\t\t  {\n\t\t    Object.seal(refObject);\n\t\t  }\n\n\t\t  return refObject;\n\t\t}\n\n\t\tvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n\t\tfunction isArray(a) {\n\t\t  return isArrayImpl(a);\n\t\t}\n\n\t\t/*\n\t\t * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n\t\t * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n\t\t *\n\t\t * The functions in this module will throw an easier-to-understand,\n\t\t * easier-to-debug exception with a clear errors message message explaining the\n\t\t * problem. (Instead of a confusing exception thrown inside the implementation\n\t\t * of the `value` object).\n\t\t */\n\t\t// $FlowFixMe only called in DEV, so void return is not possible.\n\t\tfunction typeName(value) {\n\t\t  {\n\t\t    // toStringTag is needed for namespaced types like Temporal.Instant\n\t\t    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n\t\t    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n\t\t    return type;\n\t\t  }\n\t\t} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n\t\tfunction willCoercionThrow(value) {\n\t\t  {\n\t\t    try {\n\t\t      testStringCoercion(value);\n\t\t      return false;\n\t\t    } catch (e) {\n\t\t      return true;\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction testStringCoercion(value) {\n\t\t  // If you ended up here by following an exception call stack, here's what's\n\t\t  // happened: you supplied an object or symbol value to React (as a prop, key,\n\t\t  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n\t\t  // coerce it to a string using `'' + value`, an exception was thrown.\n\t\t  //\n\t\t  // The most common types that will cause this exception are `Symbol` instances\n\t\t  // and Temporal objects like `Temporal.Instant`. But any object that has a\n\t\t  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n\t\t  // exception. (Library authors do this to prevent users from using built-in\n\t\t  // numeric operators like `+` or comparison operators like `>=` because custom\n\t\t  // methods are needed to perform accurate arithmetic or comparison.)\n\t\t  //\n\t\t  // To fix the problem, coerce this object or symbol value to a string before\n\t\t  // passing it to React. The most reliable way is usually `String(value)`.\n\t\t  //\n\t\t  // To find which value is throwing, check the browser or debugger console.\n\t\t  // Before this exception was thrown, there should be `console.error` output\n\t\t  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n\t\t  // problem and how that type was used: key, atrribute, input value prop, etc.\n\t\t  // In most cases, this console output also shows the component and its\n\t\t  // ancestor components where the exception happened.\n\t\t  //\n\t\t  // eslint-disable-next-line react-internal/safe-string-coercion\n\t\t  return '' + value;\n\t\t}\n\t\tfunction checkKeyStringCoercion(value) {\n\t\t  {\n\t\t    if (willCoercionThrow(value)) {\n\t\t      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n\t\t      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction getWrappedName(outerType, innerType, wrapperName) {\n\t\t  var displayName = outerType.displayName;\n\n\t\t  if (displayName) {\n\t\t    return displayName;\n\t\t  }\n\n\t\t  var functionName = innerType.displayName || innerType.name || '';\n\t\t  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n\t\t} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\n\t\tfunction getContextName(type) {\n\t\t  return type.displayName || 'Context';\n\t\t} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\n\t\tfunction getComponentNameFromType(type) {\n\t\t  if (type == null) {\n\t\t    // Host root, text node or just invalid type.\n\t\t    return null;\n\t\t  }\n\n\t\t  {\n\t\t    if (typeof type.tag === 'number') {\n\t\t      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n\t\t    }\n\t\t  }\n\n\t\t  if (typeof type === 'function') {\n\t\t    return type.displayName || type.name || null;\n\t\t  }\n\n\t\t  if (typeof type === 'string') {\n\t\t    return type;\n\t\t  }\n\n\t\t  switch (type) {\n\t\t    case REACT_FRAGMENT_TYPE:\n\t\t      return 'Fragment';\n\n\t\t    case REACT_PORTAL_TYPE:\n\t\t      return 'Portal';\n\n\t\t    case REACT_PROFILER_TYPE:\n\t\t      return 'Profiler';\n\n\t\t    case REACT_STRICT_MODE_TYPE:\n\t\t      return 'StrictMode';\n\n\t\t    case REACT_SUSPENSE_TYPE:\n\t\t      return 'Suspense';\n\n\t\t    case REACT_SUSPENSE_LIST_TYPE:\n\t\t      return 'SuspenseList';\n\n\t\t  }\n\n\t\t  if (typeof type === 'object') {\n\t\t    switch (type.$$typeof) {\n\t\t      case REACT_CONTEXT_TYPE:\n\t\t        var context = type;\n\t\t        return getContextName(context) + '.Consumer';\n\n\t\t      case REACT_PROVIDER_TYPE:\n\t\t        var provider = type;\n\t\t        return getContextName(provider._context) + '.Provider';\n\n\t\t      case REACT_FORWARD_REF_TYPE:\n\t\t        return getWrappedName(type, type.render, 'ForwardRef');\n\n\t\t      case REACT_MEMO_TYPE:\n\t\t        var outerName = type.displayName || null;\n\n\t\t        if (outerName !== null) {\n\t\t          return outerName;\n\t\t        }\n\n\t\t        return getComponentNameFromType(type.type) || 'Memo';\n\n\t\t      case REACT_LAZY_TYPE:\n\t\t        {\n\t\t          var lazyComponent = type;\n\t\t          var payload = lazyComponent._payload;\n\t\t          var init = lazyComponent._init;\n\n\t\t          try {\n\t\t            return getComponentNameFromType(init(payload));\n\t\t          } catch (x) {\n\t\t            return null;\n\t\t          }\n\t\t        }\n\n\t\t      // eslint-disable-next-line no-fallthrough\n\t\t    }\n\t\t  }\n\n\t\t  return null;\n\t\t}\n\n\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\t\tvar RESERVED_PROPS = {\n\t\t  key: true,\n\t\t  ref: true,\n\t\t  __self: true,\n\t\t  __source: true\n\t\t};\n\t\tvar specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\n\t\t{\n\t\t  didWarnAboutStringRefs = {};\n\t\t}\n\n\t\tfunction hasValidRef(config) {\n\t\t  {\n\t\t    if (hasOwnProperty.call(config, 'ref')) {\n\t\t      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n\t\t      if (getter && getter.isReactWarning) {\n\t\t        return false;\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  return config.ref !== undefined;\n\t\t}\n\n\t\tfunction hasValidKey(config) {\n\t\t  {\n\t\t    if (hasOwnProperty.call(config, 'key')) {\n\t\t      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n\t\t      if (getter && getter.isReactWarning) {\n\t\t        return false;\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  return config.key !== undefined;\n\t\t}\n\n\t\tfunction defineKeyPropWarningGetter(props, displayName) {\n\t\t  var warnAboutAccessingKey = function () {\n\t\t    {\n\t\t      if (!specialPropKeyWarningShown) {\n\t\t        specialPropKeyWarningShown = true;\n\n\t\t        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n\t\t      }\n\t\t    }\n\t\t  };\n\n\t\t  warnAboutAccessingKey.isReactWarning = true;\n\t\t  Object.defineProperty(props, 'key', {\n\t\t    get: warnAboutAccessingKey,\n\t\t    configurable: true\n\t\t  });\n\t\t}\n\n\t\tfunction defineRefPropWarningGetter(props, displayName) {\n\t\t  var warnAboutAccessingRef = function () {\n\t\t    {\n\t\t      if (!specialPropRefWarningShown) {\n\t\t        specialPropRefWarningShown = true;\n\n\t\t        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n\t\t      }\n\t\t    }\n\t\t  };\n\n\t\t  warnAboutAccessingRef.isReactWarning = true;\n\t\t  Object.defineProperty(props, 'ref', {\n\t\t    get: warnAboutAccessingRef,\n\t\t    configurable: true\n\t\t  });\n\t\t}\n\n\t\tfunction warnIfStringRefCannotBeAutoConverted(config) {\n\t\t  {\n\t\t    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n\t\t      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n\t\t      if (!didWarnAboutStringRefs[componentName]) {\n\t\t        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n\n\t\t        didWarnAboutStringRefs[componentName] = true;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t/**\n\t\t * Factory method to create a new React element. This no longer adheres to\n\t\t * the class pattern, so do not use new to call it. Also, instanceof check\n\t\t * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n\t\t * if something is a React Element.\n\t\t *\n\t\t * @param {*} type\n\t\t * @param {*} props\n\t\t * @param {*} key\n\t\t * @param {string|object} ref\n\t\t * @param {*} owner\n\t\t * @param {*} self A *temporary* helper to detect places where `this` is\n\t\t * different from the `owner` when React.createElement is called, so that we\n\t\t * can warn. We want to get rid of owner and replace string `ref`s with arrow\n\t\t * functions, and as long as `this` and owner are the same, there will be no\n\t\t * change in behavior.\n\t\t * @param {*} source An annotation object (added by a transpiler or otherwise)\n\t\t * indicating filename, line number, and/or other information.\n\t\t * @internal\n\t\t */\n\n\n\t\tvar ReactElement = function (type, key, ref, self, source, owner, props) {\n\t\t  var element = {\n\t\t    // This tag allows us to uniquely identify this as a React Element\n\t\t    $$typeof: REACT_ELEMENT_TYPE,\n\t\t    // Built-in properties that belong on the element\n\t\t    type: type,\n\t\t    key: key,\n\t\t    ref: ref,\n\t\t    props: props,\n\t\t    // Record the component responsible for creating this element.\n\t\t    _owner: owner\n\t\t  };\n\n\t\t  {\n\t\t    // The validation flag is currently mutative. We put it on\n\t\t    // an external backing store so that we can freeze the whole object.\n\t\t    // This can be replaced with a WeakMap once they are implemented in\n\t\t    // commonly used development environments.\n\t\t    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n\t\t    // the validation flag non-enumerable (where possible, which should\n\t\t    // include every environment we run tests in), so the test framework\n\t\t    // ignores it.\n\n\t\t    Object.defineProperty(element._store, 'validated', {\n\t\t      configurable: false,\n\t\t      enumerable: false,\n\t\t      writable: true,\n\t\t      value: false\n\t\t    }); // self and source are DEV only properties.\n\n\t\t    Object.defineProperty(element, '_self', {\n\t\t      configurable: false,\n\t\t      enumerable: false,\n\t\t      writable: false,\n\t\t      value: self\n\t\t    }); // Two elements created in two different places should be considered\n\t\t    // equal for testing purposes and therefore we hide it from enumeration.\n\n\t\t    Object.defineProperty(element, '_source', {\n\t\t      configurable: false,\n\t\t      enumerable: false,\n\t\t      writable: false,\n\t\t      value: source\n\t\t    });\n\n\t\t    if (Object.freeze) {\n\t\t      Object.freeze(element.props);\n\t\t      Object.freeze(element);\n\t\t    }\n\t\t  }\n\n\t\t  return element;\n\t\t};\n\t\t/**\n\t\t * Create and return a new ReactElement of the given type.\n\t\t * See https://reactjs.org/docs/react-api.html#createelement\n\t\t */\n\n\t\tfunction createElement(type, config, children) {\n\t\t  var propName; // Reserved names are extracted\n\n\t\t  var props = {};\n\t\t  var key = null;\n\t\t  var ref = null;\n\t\t  var self = null;\n\t\t  var source = null;\n\n\t\t  if (config != null) {\n\t\t    if (hasValidRef(config)) {\n\t\t      ref = config.ref;\n\n\t\t      {\n\t\t        warnIfStringRefCannotBeAutoConverted(config);\n\t\t      }\n\t\t    }\n\n\t\t    if (hasValidKey(config)) {\n\t\t      {\n\t\t        checkKeyStringCoercion(config.key);\n\t\t      }\n\n\t\t      key = '' + config.key;\n\t\t    }\n\n\t\t    self = config.__self === undefined ? null : config.__self;\n\t\t    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n\t\t    for (propName in config) {\n\t\t      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n\t\t        props[propName] = config[propName];\n\t\t      }\n\t\t    }\n\t\t  } // Children can be more than one argument, and those are transferred onto\n\t\t  // the newly allocated props object.\n\n\n\t\t  var childrenLength = arguments.length - 2;\n\n\t\t  if (childrenLength === 1) {\n\t\t    props.children = children;\n\t\t  } else if (childrenLength > 1) {\n\t\t    var childArray = Array(childrenLength);\n\n\t\t    for (var i = 0; i < childrenLength; i++) {\n\t\t      childArray[i] = arguments[i + 2];\n\t\t    }\n\n\t\t    {\n\t\t      if (Object.freeze) {\n\t\t        Object.freeze(childArray);\n\t\t      }\n\t\t    }\n\n\t\t    props.children = childArray;\n\t\t  } // Resolve default props\n\n\n\t\t  if (type && type.defaultProps) {\n\t\t    var defaultProps = type.defaultProps;\n\n\t\t    for (propName in defaultProps) {\n\t\t      if (props[propName] === undefined) {\n\t\t        props[propName] = defaultProps[propName];\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  {\n\t\t    if (key || ref) {\n\t\t      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n\t\t      if (key) {\n\t\t        defineKeyPropWarningGetter(props, displayName);\n\t\t      }\n\n\t\t      if (ref) {\n\t\t        defineRefPropWarningGetter(props, displayName);\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\t\t}\n\t\tfunction cloneAndReplaceKey(oldElement, newKey) {\n\t\t  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\t\t  return newElement;\n\t\t}\n\t\t/**\n\t\t * Clone and return a new ReactElement using element as the starting point.\n\t\t * See https://reactjs.org/docs/react-api.html#cloneelement\n\t\t */\n\n\t\tfunction cloneElement(element, config, children) {\n\t\t  if (element === null || element === undefined) {\n\t\t    throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n\t\t  }\n\n\t\t  var propName; // Original props are copied\n\n\t\t  var props = assign({}, element.props); // Reserved names are extracted\n\n\t\t  var key = element.key;\n\t\t  var ref = element.ref; // Self is preserved since the owner is preserved.\n\n\t\t  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n\t\t  // transpiler, and the original source is probably a better indicator of the\n\t\t  // true owner.\n\n\t\t  var source = element._source; // Owner will be preserved, unless ref is overridden\n\n\t\t  var owner = element._owner;\n\n\t\t  if (config != null) {\n\t\t    if (hasValidRef(config)) {\n\t\t      // Silently steal the ref from the parent.\n\t\t      ref = config.ref;\n\t\t      owner = ReactCurrentOwner.current;\n\t\t    }\n\n\t\t    if (hasValidKey(config)) {\n\t\t      {\n\t\t        checkKeyStringCoercion(config.key);\n\t\t      }\n\n\t\t      key = '' + config.key;\n\t\t    } // Remaining properties override existing props\n\n\n\t\t    var defaultProps;\n\n\t\t    if (element.type && element.type.defaultProps) {\n\t\t      defaultProps = element.type.defaultProps;\n\t\t    }\n\n\t\t    for (propName in config) {\n\t\t      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n\t\t        if (config[propName] === undefined && defaultProps !== undefined) {\n\t\t          // Resolve default props\n\t\t          props[propName] = defaultProps[propName];\n\t\t        } else {\n\t\t          props[propName] = config[propName];\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  } // Children can be more than one argument, and those are transferred onto\n\t\t  // the newly allocated props object.\n\n\n\t\t  var childrenLength = arguments.length - 2;\n\n\t\t  if (childrenLength === 1) {\n\t\t    props.children = children;\n\t\t  } else if (childrenLength > 1) {\n\t\t    var childArray = Array(childrenLength);\n\n\t\t    for (var i = 0; i < childrenLength; i++) {\n\t\t      childArray[i] = arguments[i + 2];\n\t\t    }\n\n\t\t    props.children = childArray;\n\t\t  }\n\n\t\t  return ReactElement(element.type, key, ref, self, source, owner, props);\n\t\t}\n\t\t/**\n\t\t * Verifies the object is a ReactElement.\n\t\t * See https://reactjs.org/docs/react-api.html#isvalidelement\n\t\t * @param {?object} object\n\t\t * @return {boolean} True if `object` is a ReactElement.\n\t\t * @final\n\t\t */\n\n\t\tfunction isValidElement(object) {\n\t\t  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n\t\t}\n\n\t\tvar SEPARATOR = '.';\n\t\tvar SUBSEPARATOR = ':';\n\t\t/**\n\t\t * Escape and wrap key so it is safe to use as a reactid\n\t\t *\n\t\t * @param {string} key to be escaped.\n\t\t * @return {string} the escaped key.\n\t\t */\n\n\t\tfunction escape(key) {\n\t\t  var escapeRegex = /[=:]/g;\n\t\t  var escaperLookup = {\n\t\t    '=': '=0',\n\t\t    ':': '=2'\n\t\t  };\n\t\t  var escapedString = key.replace(escapeRegex, function (match) {\n\t\t    return escaperLookup[match];\n\t\t  });\n\t\t  return '$' + escapedString;\n\t\t}\n\t\t/**\n\t\t * TODO: Test that a single child and an array with one item have the same key\n\t\t * pattern.\n\t\t */\n\n\n\t\tvar didWarnAboutMaps = false;\n\t\tvar userProvidedKeyEscapeRegex = /\\/+/g;\n\n\t\tfunction escapeUserProvidedKey(text) {\n\t\t  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n\t\t}\n\t\t/**\n\t\t * Generate a key string that identifies a element within a set.\n\t\t *\n\t\t * @param {*} element A element that could contain a manual key.\n\t\t * @param {number} index Index that is used if a manual key is not provided.\n\t\t * @return {string}\n\t\t */\n\n\n\t\tfunction getElementKey(element, index) {\n\t\t  // Do some typechecking here since we call this blindly. We want to ensure\n\t\t  // that we don't block potential future ES APIs.\n\t\t  if (typeof element === 'object' && element !== null && element.key != null) {\n\t\t    // Explicit key\n\t\t    {\n\t\t      checkKeyStringCoercion(element.key);\n\t\t    }\n\n\t\t    return escape('' + element.key);\n\t\t  } // Implicit key determined by the index in the set\n\n\n\t\t  return index.toString(36);\n\t\t}\n\n\t\tfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n\t\t  var type = typeof children;\n\n\t\t  if (type === 'undefined' || type === 'boolean') {\n\t\t    // All of the above are perceived as null.\n\t\t    children = null;\n\t\t  }\n\n\t\t  var invokeCallback = false;\n\n\t\t  if (children === null) {\n\t\t    invokeCallback = true;\n\t\t  } else {\n\t\t    switch (type) {\n\t\t      case 'string':\n\t\t      case 'number':\n\t\t        invokeCallback = true;\n\t\t        break;\n\n\t\t      case 'object':\n\t\t        switch (children.$$typeof) {\n\t\t          case REACT_ELEMENT_TYPE:\n\t\t          case REACT_PORTAL_TYPE:\n\t\t            invokeCallback = true;\n\t\t        }\n\n\t\t    }\n\t\t  }\n\n\t\t  if (invokeCallback) {\n\t\t    var _child = children;\n\t\t    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n\t\t    // so that it's consistent if the number of children grows:\n\n\t\t    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n\n\t\t    if (isArray(mappedChild)) {\n\t\t      var escapedChildKey = '';\n\n\t\t      if (childKey != null) {\n\t\t        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n\t\t      }\n\n\t\t      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n\t\t        return c;\n\t\t      });\n\t\t    } else if (mappedChild != null) {\n\t\t      if (isValidElement(mappedChild)) {\n\t\t        {\n\t\t          // The `if` statement here prevents auto-disabling of the safe\n\t\t          // coercion ESLint rule, so we must manually disable it below.\n\t\t          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n\t\t          if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n\t\t            checkKeyStringCoercion(mappedChild.key);\n\t\t          }\n\t\t        }\n\n\t\t        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n\t\t        // traverseAllChildren used to do for objects as children\n\t\t        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n\t\t        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n\t\t        // eslint-disable-next-line react-internal/safe-string-coercion\n\t\t        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n\t\t      }\n\n\t\t      array.push(mappedChild);\n\t\t    }\n\n\t\t    return 1;\n\t\t  }\n\n\t\t  var child;\n\t\t  var nextName;\n\t\t  var subtreeCount = 0; // Count of children found in the current subtree.\n\n\t\t  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n\t\t  if (isArray(children)) {\n\t\t    for (var i = 0; i < children.length; i++) {\n\t\t      child = children[i];\n\t\t      nextName = nextNamePrefix + getElementKey(child, i);\n\t\t      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n\t\t    }\n\t\t  } else {\n\t\t    var iteratorFn = getIteratorFn(children);\n\n\t\t    if (typeof iteratorFn === 'function') {\n\t\t      var iterableChildren = children;\n\n\t\t      {\n\t\t        // Warn about using Maps as children\n\t\t        if (iteratorFn === iterableChildren.entries) {\n\t\t          if (!didWarnAboutMaps) {\n\t\t            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n\t\t          }\n\n\t\t          didWarnAboutMaps = true;\n\t\t        }\n\t\t      }\n\n\t\t      var iterator = iteratorFn.call(iterableChildren);\n\t\t      var step;\n\t\t      var ii = 0;\n\n\t\t      while (!(step = iterator.next()).done) {\n\t\t        child = step.value;\n\t\t        nextName = nextNamePrefix + getElementKey(child, ii++);\n\t\t        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n\t\t      }\n\t\t    } else if (type === 'object') {\n\t\t      // eslint-disable-next-line react-internal/safe-string-coercion\n\t\t      var childrenString = String(children);\n\t\t      throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n\t\t    }\n\t\t  }\n\n\t\t  return subtreeCount;\n\t\t}\n\n\t\t/**\n\t\t * Maps children that are typically specified as `props.children`.\n\t\t *\n\t\t * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n\t\t *\n\t\t * The provided mapFunction(child, index) will be called for each\n\t\t * leaf child.\n\t\t *\n\t\t * @param {?*} children Children tree container.\n\t\t * @param {function(*, int)} func The map function.\n\t\t * @param {*} context Context for mapFunction.\n\t\t * @return {object} Object containing the ordered map of results.\n\t\t */\n\t\tfunction mapChildren(children, func, context) {\n\t\t  if (children == null) {\n\t\t    return children;\n\t\t  }\n\n\t\t  var result = [];\n\t\t  var count = 0;\n\t\t  mapIntoArray(children, result, '', '', function (child) {\n\t\t    return func.call(context, child, count++);\n\t\t  });\n\t\t  return result;\n\t\t}\n\t\t/**\n\t\t * Count the number of children that are typically specified as\n\t\t * `props.children`.\n\t\t *\n\t\t * See https://reactjs.org/docs/react-api.html#reactchildrencount\n\t\t *\n\t\t * @param {?*} children Children tree container.\n\t\t * @return {number} The number of children.\n\t\t */\n\n\n\t\tfunction countChildren(children) {\n\t\t  var n = 0;\n\t\t  mapChildren(children, function () {\n\t\t    n++; // Don't return anything\n\t\t  });\n\t\t  return n;\n\t\t}\n\n\t\t/**\n\t\t * Iterates through children that are typically specified as `props.children`.\n\t\t *\n\t\t * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n\t\t *\n\t\t * The provided forEachFunc(child, index) will be called for each\n\t\t * leaf child.\n\t\t *\n\t\t * @param {?*} children Children tree container.\n\t\t * @param {function(*, int)} forEachFunc\n\t\t * @param {*} forEachContext Context for forEachContext.\n\t\t */\n\t\tfunction forEachChildren(children, forEachFunc, forEachContext) {\n\t\t  mapChildren(children, function () {\n\t\t    forEachFunc.apply(this, arguments); // Don't return anything.\n\t\t  }, forEachContext);\n\t\t}\n\t\t/**\n\t\t * Flatten a children object (typically specified as `props.children`) and\n\t\t * return an array with appropriately re-keyed children.\n\t\t *\n\t\t * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n\t\t */\n\n\n\t\tfunction toArray(children) {\n\t\t  return mapChildren(children, function (child) {\n\t\t    return child;\n\t\t  }) || [];\n\t\t}\n\t\t/**\n\t\t * Returns the first child in a collection of children and verifies that there\n\t\t * is only one child in the collection.\n\t\t *\n\t\t * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n\t\t *\n\t\t * The current implementation of this function assumes that a single child gets\n\t\t * passed without a wrapper, but the purpose of this helper function is to\n\t\t * abstract away the particular structure of children.\n\t\t *\n\t\t * @param {?object} children Child collection structure.\n\t\t * @return {ReactElement} The first and only `ReactElement` contained in the\n\t\t * structure.\n\t\t */\n\n\n\t\tfunction onlyChild(children) {\n\t\t  if (!isValidElement(children)) {\n\t\t    throw new Error('React.Children.only expected to receive a single React element child.');\n\t\t  }\n\n\t\t  return children;\n\t\t}\n\n\t\tfunction createContext(defaultValue) {\n\t\t  // TODO: Second argument used to be an optional `calculateChangedBits`\n\t\t  // function. Warn to reserve for future use?\n\t\t  var context = {\n\t\t    $$typeof: REACT_CONTEXT_TYPE,\n\t\t    // As a workaround to support multiple concurrent renderers, we categorize\n\t\t    // some renderers as primary and others as secondary. We only expect\n\t\t    // there to be two concurrent renderers at most: React Native (primary) and\n\t\t    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n\t\t    // Secondary renderers store their context values on separate fields.\n\t\t    _currentValue: defaultValue,\n\t\t    _currentValue2: defaultValue,\n\t\t    // Used to track how many concurrent renderers this context currently\n\t\t    // supports within in a single renderer. Such as parallel server rendering.\n\t\t    _threadCount: 0,\n\t\t    // These are circular\n\t\t    Provider: null,\n\t\t    Consumer: null,\n\t\t    // Add these to use same hidden class in VM as ServerContext\n\t\t    _defaultValue: null,\n\t\t    _globalName: null\n\t\t  };\n\t\t  context.Provider = {\n\t\t    $$typeof: REACT_PROVIDER_TYPE,\n\t\t    _context: context\n\t\t  };\n\t\t  var hasWarnedAboutUsingNestedContextConsumers = false;\n\t\t  var hasWarnedAboutUsingConsumerProvider = false;\n\t\t  var hasWarnedAboutDisplayNameOnConsumer = false;\n\n\t\t  {\n\t\t    // A separate object, but proxies back to the original context object for\n\t\t    // backwards compatibility. It has a different $$typeof, so we can properly\n\t\t    // warn for the incorrect usage of Context as a Consumer.\n\t\t    var Consumer = {\n\t\t      $$typeof: REACT_CONTEXT_TYPE,\n\t\t      _context: context\n\t\t    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n\t\t    Object.defineProperties(Consumer, {\n\t\t      Provider: {\n\t\t        get: function () {\n\t\t          if (!hasWarnedAboutUsingConsumerProvider) {\n\t\t            hasWarnedAboutUsingConsumerProvider = true;\n\n\t\t            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n\t\t          }\n\n\t\t          return context.Provider;\n\t\t        },\n\t\t        set: function (_Provider) {\n\t\t          context.Provider = _Provider;\n\t\t        }\n\t\t      },\n\t\t      _currentValue: {\n\t\t        get: function () {\n\t\t          return context._currentValue;\n\t\t        },\n\t\t        set: function (_currentValue) {\n\t\t          context._currentValue = _currentValue;\n\t\t        }\n\t\t      },\n\t\t      _currentValue2: {\n\t\t        get: function () {\n\t\t          return context._currentValue2;\n\t\t        },\n\t\t        set: function (_currentValue2) {\n\t\t          context._currentValue2 = _currentValue2;\n\t\t        }\n\t\t      },\n\t\t      _threadCount: {\n\t\t        get: function () {\n\t\t          return context._threadCount;\n\t\t        },\n\t\t        set: function (_threadCount) {\n\t\t          context._threadCount = _threadCount;\n\t\t        }\n\t\t      },\n\t\t      Consumer: {\n\t\t        get: function () {\n\t\t          if (!hasWarnedAboutUsingNestedContextConsumers) {\n\t\t            hasWarnedAboutUsingNestedContextConsumers = true;\n\n\t\t            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n\t\t          }\n\n\t\t          return context.Consumer;\n\t\t        }\n\t\t      },\n\t\t      displayName: {\n\t\t        get: function () {\n\t\t          return context.displayName;\n\t\t        },\n\t\t        set: function (displayName) {\n\t\t          if (!hasWarnedAboutDisplayNameOnConsumer) {\n\t\t            warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n\n\t\t            hasWarnedAboutDisplayNameOnConsumer = true;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n\t\t    context.Consumer = Consumer;\n\t\t  }\n\n\t\t  {\n\t\t    context._currentRenderer = null;\n\t\t    context._currentRenderer2 = null;\n\t\t  }\n\n\t\t  return context;\n\t\t}\n\n\t\tvar Uninitialized = -1;\n\t\tvar Pending = 0;\n\t\tvar Resolved = 1;\n\t\tvar Rejected = 2;\n\n\t\tfunction lazyInitializer(payload) {\n\t\t  if (payload._status === Uninitialized) {\n\t\t    var ctor = payload._result;\n\t\t    var thenable = ctor(); // Transition to the next state.\n\t\t    // This might throw either because it's missing or throws. If so, we treat it\n\t\t    // as still uninitialized and try again next time. Which is the same as what\n\t\t    // happens if the ctor or any wrappers processing the ctor throws. This might\n\t\t    // end up fixing it if the resolution was a concurrency bug.\n\n\t\t    thenable.then(function (moduleObject) {\n\t\t      if (payload._status === Pending || payload._status === Uninitialized) {\n\t\t        // Transition to the next state.\n\t\t        var resolved = payload;\n\t\t        resolved._status = Resolved;\n\t\t        resolved._result = moduleObject;\n\t\t      }\n\t\t    }, function (error) {\n\t\t      if (payload._status === Pending || payload._status === Uninitialized) {\n\t\t        // Transition to the next state.\n\t\t        var rejected = payload;\n\t\t        rejected._status = Rejected;\n\t\t        rejected._result = error;\n\t\t      }\n\t\t    });\n\n\t\t    if (payload._status === Uninitialized) {\n\t\t      // In case, we're still uninitialized, then we're waiting for the thenable\n\t\t      // to resolve. Set it as pending in the meantime.\n\t\t      var pending = payload;\n\t\t      pending._status = Pending;\n\t\t      pending._result = thenable;\n\t\t    }\n\t\t  }\n\n\t\t  if (payload._status === Resolved) {\n\t\t    var moduleObject = payload._result;\n\n\t\t    {\n\t\t      if (moduleObject === undefined) {\n\t\t        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n\t\t        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n\t\t      }\n\t\t    }\n\n\t\t    {\n\t\t      if (!('default' in moduleObject)) {\n\t\t        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n\t\t        'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n\t\t      }\n\t\t    }\n\n\t\t    return moduleObject.default;\n\t\t  } else {\n\t\t    throw payload._result;\n\t\t  }\n\t\t}\n\n\t\tfunction lazy(ctor) {\n\t\t  var payload = {\n\t\t    // We use these fields to store the result.\n\t\t    _status: Uninitialized,\n\t\t    _result: ctor\n\t\t  };\n\t\t  var lazyType = {\n\t\t    $$typeof: REACT_LAZY_TYPE,\n\t\t    _payload: payload,\n\t\t    _init: lazyInitializer\n\t\t  };\n\n\t\t  {\n\t\t    // In production, this would just set it on the object.\n\t\t    var defaultProps;\n\t\t    var propTypes; // $FlowFixMe\n\n\t\t    Object.defineProperties(lazyType, {\n\t\t      defaultProps: {\n\t\t        configurable: true,\n\t\t        get: function () {\n\t\t          return defaultProps;\n\t\t        },\n\t\t        set: function (newDefaultProps) {\n\t\t          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n\t\t          defaultProps = newDefaultProps; // Match production behavior more closely:\n\t\t          // $FlowFixMe\n\n\t\t          Object.defineProperty(lazyType, 'defaultProps', {\n\t\t            enumerable: true\n\t\t          });\n\t\t        }\n\t\t      },\n\t\t      propTypes: {\n\t\t        configurable: true,\n\t\t        get: function () {\n\t\t          return propTypes;\n\t\t        },\n\t\t        set: function (newPropTypes) {\n\t\t          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n\t\t          propTypes = newPropTypes; // Match production behavior more closely:\n\t\t          // $FlowFixMe\n\n\t\t          Object.defineProperty(lazyType, 'propTypes', {\n\t\t            enumerable: true\n\t\t          });\n\t\t        }\n\t\t      }\n\t\t    });\n\t\t  }\n\n\t\t  return lazyType;\n\t\t}\n\n\t\tfunction forwardRef(render) {\n\t\t  {\n\t\t    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n\t\t      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n\t\t    } else if (typeof render !== 'function') {\n\t\t      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n\t\t    } else {\n\t\t      if (render.length !== 0 && render.length !== 2) {\n\t\t        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n\t\t      }\n\t\t    }\n\n\t\t    if (render != null) {\n\t\t      if (render.defaultProps != null || render.propTypes != null) {\n\t\t        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  var elementType = {\n\t\t    $$typeof: REACT_FORWARD_REF_TYPE,\n\t\t    render: render\n\t\t  };\n\n\t\t  {\n\t\t    var ownName;\n\t\t    Object.defineProperty(elementType, 'displayName', {\n\t\t      enumerable: false,\n\t\t      configurable: true,\n\t\t      get: function () {\n\t\t        return ownName;\n\t\t      },\n\t\t      set: function (name) {\n\t\t        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n\t\t        // because the component may be used elsewhere.\n\t\t        // But it's nice for anonymous functions to inherit the name,\n\t\t        // so that our component-stack generation logic will display their frames.\n\t\t        // An anonymous function generally suggests a pattern like:\n\t\t        //   React.forwardRef((props, ref) => {...});\n\t\t        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n\t\t        if (!render.name && !render.displayName) {\n\t\t          render.displayName = name;\n\t\t        }\n\t\t      }\n\t\t    });\n\t\t  }\n\n\t\t  return elementType;\n\t\t}\n\n\t\tvar REACT_MODULE_REFERENCE;\n\n\t\t{\n\t\t  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n\t\t}\n\n\t\tfunction isValidElementType(type) {\n\t\t  if (typeof type === 'string' || typeof type === 'function') {\n\t\t    return true;\n\t\t  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n\t\t  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n\t\t    return true;\n\t\t  }\n\n\t\t  if (typeof type === 'object' && type !== null) {\n\t\t    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n\t\t    // types supported by any Flight configuration anywhere since\n\t\t    // we don't know which Flight build this will end up being used\n\t\t    // with.\n\t\t    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n\t\t      return true;\n\t\t    }\n\t\t  }\n\n\t\t  return false;\n\t\t}\n\n\t\tfunction memo(type, compare) {\n\t\t  {\n\t\t    if (!isValidElementType(type)) {\n\t\t      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n\t\t    }\n\t\t  }\n\n\t\t  var elementType = {\n\t\t    $$typeof: REACT_MEMO_TYPE,\n\t\t    type: type,\n\t\t    compare: compare === undefined ? null : compare\n\t\t  };\n\n\t\t  {\n\t\t    var ownName;\n\t\t    Object.defineProperty(elementType, 'displayName', {\n\t\t      enumerable: false,\n\t\t      configurable: true,\n\t\t      get: function () {\n\t\t        return ownName;\n\t\t      },\n\t\t      set: function (name) {\n\t\t        ownName = name; // The inner component shouldn't inherit this display name in most cases,\n\t\t        // because the component may be used elsewhere.\n\t\t        // But it's nice for anonymous functions to inherit the name,\n\t\t        // so that our component-stack generation logic will display their frames.\n\t\t        // An anonymous function generally suggests a pattern like:\n\t\t        //   React.memo((props) => {...});\n\t\t        // This kind of inner function is not used elsewhere so the side effect is okay.\n\n\t\t        if (!type.name && !type.displayName) {\n\t\t          type.displayName = name;\n\t\t        }\n\t\t      }\n\t\t    });\n\t\t  }\n\n\t\t  return elementType;\n\t\t}\n\n\t\tfunction resolveDispatcher() {\n\t\t  var dispatcher = ReactCurrentDispatcher.current;\n\n\t\t  {\n\t\t    if (dispatcher === null) {\n\t\t      error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n\t\t    }\n\t\t  } // Will result in a null access error if accessed outside render phase. We\n\t\t  // intentionally don't throw our own error because this is in a hot path.\n\t\t  // Also helps ensure this is inlined.\n\n\n\t\t  return dispatcher;\n\t\t}\n\t\tfunction useContext(Context) {\n\t\t  var dispatcher = resolveDispatcher();\n\n\t\t  {\n\t\t    // TODO: add a more generic warning for invalid values.\n\t\t    if (Context._context !== undefined) {\n\t\t      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n\t\t      // and nobody should be using this in existing code.\n\n\t\t      if (realContext.Consumer === Context) {\n\t\t        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n\t\t      } else if (realContext.Provider === Context) {\n\t\t        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n\t\t      }\n\t\t    }\n\t\t  }\n\n\t\t  return dispatcher.useContext(Context);\n\t\t}\n\t\tfunction useState(initialState) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useState(initialState);\n\t\t}\n\t\tfunction useReducer(reducer, initialArg, init) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useReducer(reducer, initialArg, init);\n\t\t}\n\t\tfunction useRef(initialValue) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useRef(initialValue);\n\t\t}\n\t\tfunction useEffect(create, deps) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useEffect(create, deps);\n\t\t}\n\t\tfunction useInsertionEffect(create, deps) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useInsertionEffect(create, deps);\n\t\t}\n\t\tfunction useLayoutEffect(create, deps) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useLayoutEffect(create, deps);\n\t\t}\n\t\tfunction useCallback(callback, deps) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useCallback(callback, deps);\n\t\t}\n\t\tfunction useMemo(create, deps) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useMemo(create, deps);\n\t\t}\n\t\tfunction useImperativeHandle(ref, create, deps) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useImperativeHandle(ref, create, deps);\n\t\t}\n\t\tfunction useDebugValue(value, formatterFn) {\n\t\t  {\n\t\t    var dispatcher = resolveDispatcher();\n\t\t    return dispatcher.useDebugValue(value, formatterFn);\n\t\t  }\n\t\t}\n\t\tfunction useTransition() {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useTransition();\n\t\t}\n\t\tfunction useDeferredValue(value) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useDeferredValue(value);\n\t\t}\n\t\tfunction useId() {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useId();\n\t\t}\n\t\tfunction useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n\t\t  var dispatcher = resolveDispatcher();\n\t\t  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n\t\t}\n\n\t\t// Helpers to patch console.logs to avoid logging during side-effect free\n\t\t// replaying on render function. This currently only patches the object\n\t\t// lazily which won't cover if the log function was extracted eagerly.\n\t\t// We could also eagerly patch the method.\n\t\tvar disabledDepth = 0;\n\t\tvar prevLog;\n\t\tvar prevInfo;\n\t\tvar prevWarn;\n\t\tvar prevError;\n\t\tvar prevGroup;\n\t\tvar prevGroupCollapsed;\n\t\tvar prevGroupEnd;\n\n\t\tfunction disabledLog() {}\n\n\t\tdisabledLog.__reactDisabledLog = true;\n\t\tfunction disableLogs() {\n\t\t  {\n\t\t    if (disabledDepth === 0) {\n\t\t      /* eslint-disable react-internal/no-production-logging */\n\t\t      prevLog = console.log;\n\t\t      prevInfo = console.info;\n\t\t      prevWarn = console.warn;\n\t\t      prevError = console.error;\n\t\t      prevGroup = console.group;\n\t\t      prevGroupCollapsed = console.groupCollapsed;\n\t\t      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n\t\t      var props = {\n\t\t        configurable: true,\n\t\t        enumerable: true,\n\t\t        value: disabledLog,\n\t\t        writable: true\n\t\t      }; // $FlowFixMe Flow thinks console is immutable.\n\n\t\t      Object.defineProperties(console, {\n\t\t        info: props,\n\t\t        log: props,\n\t\t        warn: props,\n\t\t        error: props,\n\t\t        group: props,\n\t\t        groupCollapsed: props,\n\t\t        groupEnd: props\n\t\t      });\n\t\t      /* eslint-enable react-internal/no-production-logging */\n\t\t    }\n\n\t\t    disabledDepth++;\n\t\t  }\n\t\t}\n\t\tfunction reenableLogs() {\n\t\t  {\n\t\t    disabledDepth--;\n\n\t\t    if (disabledDepth === 0) {\n\t\t      /* eslint-disable react-internal/no-production-logging */\n\t\t      var props = {\n\t\t        configurable: true,\n\t\t        enumerable: true,\n\t\t        writable: true\n\t\t      }; // $FlowFixMe Flow thinks console is immutable.\n\n\t\t      Object.defineProperties(console, {\n\t\t        log: assign({}, props, {\n\t\t          value: prevLog\n\t\t        }),\n\t\t        info: assign({}, props, {\n\t\t          value: prevInfo\n\t\t        }),\n\t\t        warn: assign({}, props, {\n\t\t          value: prevWarn\n\t\t        }),\n\t\t        error: assign({}, props, {\n\t\t          value: prevError\n\t\t        }),\n\t\t        group: assign({}, props, {\n\t\t          value: prevGroup\n\t\t        }),\n\t\t        groupCollapsed: assign({}, props, {\n\t\t          value: prevGroupCollapsed\n\t\t        }),\n\t\t        groupEnd: assign({}, props, {\n\t\t          value: prevGroupEnd\n\t\t        })\n\t\t      });\n\t\t      /* eslint-enable react-internal/no-production-logging */\n\t\t    }\n\n\t\t    if (disabledDepth < 0) {\n\t\t      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n\t\tvar prefix;\n\t\tfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n\t\t  {\n\t\t    if (prefix === undefined) {\n\t\t      // Extract the VM specific prefix used by each line.\n\t\t      try {\n\t\t        throw Error();\n\t\t      } catch (x) {\n\t\t        var match = x.stack.trim().match(/\\n( *(at )?)/);\n\t\t        prefix = match && match[1] || '';\n\t\t      }\n\t\t    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n\t\t    return '\\n' + prefix + name;\n\t\t  }\n\t\t}\n\t\tvar reentry = false;\n\t\tvar componentFrameCache;\n\n\t\t{\n\t\t  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\t\t  componentFrameCache = new PossiblyWeakMap();\n\t\t}\n\n\t\tfunction describeNativeComponentFrame(fn, construct) {\n\t\t  // If something asked for a stack inside a fake render, it should get ignored.\n\t\t  if ( !fn || reentry) {\n\t\t    return '';\n\t\t  }\n\n\t\t  {\n\t\t    var frame = componentFrameCache.get(fn);\n\n\t\t    if (frame !== undefined) {\n\t\t      return frame;\n\t\t    }\n\t\t  }\n\n\t\t  var control;\n\t\t  reentry = true;\n\t\t  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n\t\t  Error.prepareStackTrace = undefined;\n\t\t  var previousDispatcher;\n\n\t\t  {\n\t\t    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n\t\t    // for warnings.\n\n\t\t    ReactCurrentDispatcher$1.current = null;\n\t\t    disableLogs();\n\t\t  }\n\n\t\t  try {\n\t\t    // This should throw.\n\t\t    if (construct) {\n\t\t      // Something should be setting the props in the constructor.\n\t\t      var Fake = function () {\n\t\t        throw Error();\n\t\t      }; // $FlowFixMe\n\n\n\t\t      Object.defineProperty(Fake.prototype, 'props', {\n\t\t        set: function () {\n\t\t          // We use a throwing setter instead of frozen or non-writable props\n\t\t          // because that won't throw in a non-strict mode function.\n\t\t          throw Error();\n\t\t        }\n\t\t      });\n\n\t\t      if (typeof Reflect === 'object' && Reflect.construct) {\n\t\t        // We construct a different control for this case to include any extra\n\t\t        // frames added by the construct call.\n\t\t        try {\n\t\t          Reflect.construct(Fake, []);\n\t\t        } catch (x) {\n\t\t          control = x;\n\t\t        }\n\n\t\t        Reflect.construct(fn, [], Fake);\n\t\t      } else {\n\t\t        try {\n\t\t          Fake.call();\n\t\t        } catch (x) {\n\t\t          control = x;\n\t\t        }\n\n\t\t        fn.call(Fake.prototype);\n\t\t      }\n\t\t    } else {\n\t\t      try {\n\t\t        throw Error();\n\t\t      } catch (x) {\n\t\t        control = x;\n\t\t      }\n\n\t\t      fn();\n\t\t    }\n\t\t  } catch (sample) {\n\t\t    // This is inlined manually because closure doesn't do it for us.\n\t\t    if (sample && control && typeof sample.stack === 'string') {\n\t\t      // This extracts the first frame from the sample that isn't also in the control.\n\t\t      // Skipping one frame that we assume is the frame that calls the two.\n\t\t      var sampleLines = sample.stack.split('\\n');\n\t\t      var controlLines = control.stack.split('\\n');\n\t\t      var s = sampleLines.length - 1;\n\t\t      var c = controlLines.length - 1;\n\n\t\t      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n\t\t        // We expect at least one stack frame to be shared.\n\t\t        // Typically this will be the root most one. However, stack frames may be\n\t\t        // cut off due to maximum stack limits. In this case, one maybe cut off\n\t\t        // earlier than the other. We assume that the sample is longer or the same\n\t\t        // and there for cut off earlier. So we should find the root most frame in\n\t\t        // the sample somewhere in the control.\n\t\t        c--;\n\t\t      }\n\n\t\t      for (; s >= 1 && c >= 0; s--, c--) {\n\t\t        // Next we find the first one that isn't the same which should be the\n\t\t        // frame that called our sample function and the control.\n\t\t        if (sampleLines[s] !== controlLines[c]) {\n\t\t          // In V8, the first line is describing the message but other VMs don't.\n\t\t          // If we're about to return the first line, and the control is also on the same\n\t\t          // line, that's a pretty good indicator that our sample threw at same line as\n\t\t          // the control. I.e. before we entered the sample frame. So we ignore this result.\n\t\t          // This can happen if you passed a class to function component, or non-function.\n\t\t          if (s !== 1 || c !== 1) {\n\t\t            do {\n\t\t              s--;\n\t\t              c--; // We may still have similar intermediate frames from the construct call.\n\t\t              // The next one that isn't the same should be our match though.\n\n\t\t              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n\t\t                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n\t\t                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n\t\t                // but we have a user-provided \"displayName\"\n\t\t                // splice it in to make the stack more readable.\n\n\n\t\t                if (fn.displayName && _frame.includes('<anonymous>')) {\n\t\t                  _frame = _frame.replace('<anonymous>', fn.displayName);\n\t\t                }\n\n\t\t                {\n\t\t                  if (typeof fn === 'function') {\n\t\t                    componentFrameCache.set(fn, _frame);\n\t\t                  }\n\t\t                } // Return the line we found.\n\n\n\t\t                return _frame;\n\t\t              }\n\t\t            } while (s >= 1 && c >= 0);\n\t\t          }\n\n\t\t          break;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  } finally {\n\t\t    reentry = false;\n\n\t\t    {\n\t\t      ReactCurrentDispatcher$1.current = previousDispatcher;\n\t\t      reenableLogs();\n\t\t    }\n\n\t\t    Error.prepareStackTrace = previousPrepareStackTrace;\n\t\t  } // Fallback to just using the name if we couldn't make it throw.\n\n\n\t\t  var name = fn ? fn.displayName || fn.name : '';\n\t\t  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n\t\t  {\n\t\t    if (typeof fn === 'function') {\n\t\t      componentFrameCache.set(fn, syntheticFrame);\n\t\t    }\n\t\t  }\n\n\t\t  return syntheticFrame;\n\t\t}\n\t\tfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n\t\t  {\n\t\t    return describeNativeComponentFrame(fn, false);\n\t\t  }\n\t\t}\n\n\t\tfunction shouldConstruct(Component) {\n\t\t  var prototype = Component.prototype;\n\t\t  return !!(prototype && prototype.isReactComponent);\n\t\t}\n\n\t\tfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n\t\t  if (type == null) {\n\t\t    return '';\n\t\t  }\n\n\t\t  if (typeof type === 'function') {\n\t\t    {\n\t\t      return describeNativeComponentFrame(type, shouldConstruct(type));\n\t\t    }\n\t\t  }\n\n\t\t  if (typeof type === 'string') {\n\t\t    return describeBuiltInComponentFrame(type);\n\t\t  }\n\n\t\t  switch (type) {\n\t\t    case REACT_SUSPENSE_TYPE:\n\t\t      return describeBuiltInComponentFrame('Suspense');\n\n\t\t    case REACT_SUSPENSE_LIST_TYPE:\n\t\t      return describeBuiltInComponentFrame('SuspenseList');\n\t\t  }\n\n\t\t  if (typeof type === 'object') {\n\t\t    switch (type.$$typeof) {\n\t\t      case REACT_FORWARD_REF_TYPE:\n\t\t        return describeFunctionComponentFrame(type.render);\n\n\t\t      case REACT_MEMO_TYPE:\n\t\t        // Memo may contain any component type so we recursively resolve it.\n\t\t        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n\t\t      case REACT_LAZY_TYPE:\n\t\t        {\n\t\t          var lazyComponent = type;\n\t\t          var payload = lazyComponent._payload;\n\t\t          var init = lazyComponent._init;\n\n\t\t          try {\n\t\t            // Lazy may contain any component type so we recursively resolve it.\n\t\t            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n\t\t          } catch (x) {}\n\t\t        }\n\t\t    }\n\t\t  }\n\n\t\t  return '';\n\t\t}\n\n\t\tvar loggedTypeFailures = {};\n\t\tvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n\t\tfunction setCurrentlyValidatingElement(element) {\n\t\t  {\n\t\t    if (element) {\n\t\t      var owner = element._owner;\n\t\t      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n\t\t      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n\t\t    } else {\n\t\t      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n\t\t  {\n\t\t    // $FlowFixMe This is okay but Flow doesn't know it.\n\t\t    var has = Function.call.bind(hasOwnProperty);\n\n\t\t    for (var typeSpecName in typeSpecs) {\n\t\t      if (has(typeSpecs, typeSpecName)) {\n\t\t        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n\t\t        // fail the render phase where it didn't fail before. So we log it.\n\t\t        // After these have been cleaned up, we'll let them throw.\n\n\t\t        try {\n\t\t          // This is intentionally an invariant that gets caught. It's the same\n\t\t          // behavior as without this statement except with a better message.\n\t\t          if (typeof typeSpecs[typeSpecName] !== 'function') {\n\t\t            // eslint-disable-next-line react-internal/prod-error-codes\n\t\t            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n\t\t            err.name = 'Invariant Violation';\n\t\t            throw err;\n\t\t          }\n\n\t\t          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n\t\t        } catch (ex) {\n\t\t          error$1 = ex;\n\t\t        }\n\n\t\t        if (error$1 && !(error$1 instanceof Error)) {\n\t\t          setCurrentlyValidatingElement(element);\n\n\t\t          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n\t\t          setCurrentlyValidatingElement(null);\n\t\t        }\n\n\t\t        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n\t\t          // Only monitor this failure once because there tends to be a lot of the\n\t\t          // same error.\n\t\t          loggedTypeFailures[error$1.message] = true;\n\t\t          setCurrentlyValidatingElement(element);\n\n\t\t          error('Failed %s type: %s', location, error$1.message);\n\n\t\t          setCurrentlyValidatingElement(null);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction setCurrentlyValidatingElement$1(element) {\n\t\t  {\n\t\t    if (element) {\n\t\t      var owner = element._owner;\n\t\t      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n\t\t      setExtraStackFrame(stack);\n\t\t    } else {\n\t\t      setExtraStackFrame(null);\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tvar propTypesMisspellWarningShown;\n\n\t\t{\n\t\t  propTypesMisspellWarningShown = false;\n\t\t}\n\n\t\tfunction getDeclarationErrorAddendum() {\n\t\t  if (ReactCurrentOwner.current) {\n\t\t    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n\t\t    if (name) {\n\t\t      return '\\n\\nCheck the render method of `' + name + '`.';\n\t\t    }\n\t\t  }\n\n\t\t  return '';\n\t\t}\n\n\t\tfunction getSourceInfoErrorAddendum(source) {\n\t\t  if (source !== undefined) {\n\t\t    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n\t\t    var lineNumber = source.lineNumber;\n\t\t    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n\t\t  }\n\n\t\t  return '';\n\t\t}\n\n\t\tfunction getSourceInfoErrorAddendumForProps(elementProps) {\n\t\t  if (elementProps !== null && elementProps !== undefined) {\n\t\t    return getSourceInfoErrorAddendum(elementProps.__source);\n\t\t  }\n\n\t\t  return '';\n\t\t}\n\t\t/**\n\t\t * Warn if there's no key explicitly set on dynamic arrays of children or\n\t\t * object keys are not valid. This allows us to keep track of children between\n\t\t * updates.\n\t\t */\n\n\n\t\tvar ownerHasKeyUseWarning = {};\n\n\t\tfunction getCurrentComponentErrorInfo(parentType) {\n\t\t  var info = getDeclarationErrorAddendum();\n\n\t\t  if (!info) {\n\t\t    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n\t\t    if (parentName) {\n\t\t      info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n\t\t    }\n\t\t  }\n\n\t\t  return info;\n\t\t}\n\t\t/**\n\t\t * Warn if the element doesn't have an explicit key assigned to it.\n\t\t * This element is in an array. The array could grow and shrink or be\n\t\t * reordered. All children that haven't already been validated are required to\n\t\t * have a \"key\" property assigned to it. Error statuses are cached so a warning\n\t\t * will only be shown once.\n\t\t *\n\t\t * @internal\n\t\t * @param {ReactElement} element Element that requires a key.\n\t\t * @param {*} parentType element's parent's type.\n\t\t */\n\n\n\t\tfunction validateExplicitKey(element, parentType) {\n\t\t  if (!element._store || element._store.validated || element.key != null) {\n\t\t    return;\n\t\t  }\n\n\t\t  element._store.validated = true;\n\t\t  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n\t\t  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n\t\t    return;\n\t\t  }\n\n\t\t  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n\t\t  // property, it may be the creator of the child that's responsible for\n\t\t  // assigning it a key.\n\n\t\t  var childOwner = '';\n\n\t\t  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n\t\t    // Give the component that originally created this child.\n\t\t    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n\t\t  }\n\n\t\t  {\n\t\t    setCurrentlyValidatingElement$1(element);\n\n\t\t    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n\t\t    setCurrentlyValidatingElement$1(null);\n\t\t  }\n\t\t}\n\t\t/**\n\t\t * Ensure that every element either is passed in a static location, in an\n\t\t * array with an explicit keys property defined, or in an object literal\n\t\t * with valid key property.\n\t\t *\n\t\t * @internal\n\t\t * @param {ReactNode} node Statically passed child of any type.\n\t\t * @param {*} parentType node's parent's type.\n\t\t */\n\n\n\t\tfunction validateChildKeys(node, parentType) {\n\t\t  if (typeof node !== 'object') {\n\t\t    return;\n\t\t  }\n\n\t\t  if (isArray(node)) {\n\t\t    for (var i = 0; i < node.length; i++) {\n\t\t      var child = node[i];\n\n\t\t      if (isValidElement(child)) {\n\t\t        validateExplicitKey(child, parentType);\n\t\t      }\n\t\t    }\n\t\t  } else if (isValidElement(node)) {\n\t\t    // This element was passed in a valid location.\n\t\t    if (node._store) {\n\t\t      node._store.validated = true;\n\t\t    }\n\t\t  } else if (node) {\n\t\t    var iteratorFn = getIteratorFn(node);\n\n\t\t    if (typeof iteratorFn === 'function') {\n\t\t      // Entry iterators used to provide implicit keys,\n\t\t      // but now we print a separate warning for them later.\n\t\t      if (iteratorFn !== node.entries) {\n\t\t        var iterator = iteratorFn.call(node);\n\t\t        var step;\n\n\t\t        while (!(step = iterator.next()).done) {\n\t\t          if (isValidElement(step.value)) {\n\t\t            validateExplicitKey(step.value, parentType);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\t\t/**\n\t\t * Given an element, validate that its props follow the propTypes definition,\n\t\t * provided by the type.\n\t\t *\n\t\t * @param {ReactElement} element\n\t\t */\n\n\n\t\tfunction validatePropTypes(element) {\n\t\t  {\n\t\t    var type = element.type;\n\n\t\t    if (type === null || type === undefined || typeof type === 'string') {\n\t\t      return;\n\t\t    }\n\n\t\t    var propTypes;\n\n\t\t    if (typeof type === 'function') {\n\t\t      propTypes = type.propTypes;\n\t\t    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n\t\t    // Inner props are checked in the reconciler.\n\t\t    type.$$typeof === REACT_MEMO_TYPE)) {\n\t\t      propTypes = type.propTypes;\n\t\t    } else {\n\t\t      return;\n\t\t    }\n\n\t\t    if (propTypes) {\n\t\t      // Intentionally inside to avoid triggering lazy initializers:\n\t\t      var name = getComponentNameFromType(type);\n\t\t      checkPropTypes(propTypes, element.props, 'prop', name, element);\n\t\t    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n\t\t      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n\t\t      var _name = getComponentNameFromType(type);\n\n\t\t      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n\t\t    }\n\n\t\t    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n\t\t      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n\t\t    }\n\t\t  }\n\t\t}\n\t\t/**\n\t\t * Given a fragment, validate that it can only be provided with fragment props\n\t\t * @param {ReactElement} fragment\n\t\t */\n\n\n\t\tfunction validateFragmentProps(fragment) {\n\t\t  {\n\t\t    var keys = Object.keys(fragment.props);\n\n\t\t    for (var i = 0; i < keys.length; i++) {\n\t\t      var key = keys[i];\n\n\t\t      if (key !== 'children' && key !== 'key') {\n\t\t        setCurrentlyValidatingElement$1(fragment);\n\n\t\t        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n\t\t        setCurrentlyValidatingElement$1(null);\n\t\t        break;\n\t\t      }\n\t\t    }\n\n\t\t    if (fragment.ref !== null) {\n\t\t      setCurrentlyValidatingElement$1(fragment);\n\n\t\t      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n\t\t      setCurrentlyValidatingElement$1(null);\n\t\t    }\n\t\t  }\n\t\t}\n\t\tfunction createElementWithValidation(type, props, children) {\n\t\t  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n\t\t  // succeed and there will likely be errors in render.\n\n\t\t  if (!validType) {\n\t\t    var info = '';\n\n\t\t    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n\t\t      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n\t\t    }\n\n\t\t    var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n\t\t    if (sourceInfo) {\n\t\t      info += sourceInfo;\n\t\t    } else {\n\t\t      info += getDeclarationErrorAddendum();\n\t\t    }\n\n\t\t    var typeString;\n\n\t\t    if (type === null) {\n\t\t      typeString = 'null';\n\t\t    } else if (isArray(type)) {\n\t\t      typeString = 'array';\n\t\t    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n\t\t      typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n\t\t      info = ' Did you accidentally export a JSX literal instead of a component?';\n\t\t    } else {\n\t\t      typeString = typeof type;\n\t\t    }\n\n\t\t    {\n\t\t      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n\t\t    }\n\t\t  }\n\n\t\t  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n\t\t  // TODO: Drop this when these are no longer allowed as the type argument.\n\n\t\t  if (element == null) {\n\t\t    return element;\n\t\t  } // Skip key warning if the type isn't valid since our key validation logic\n\t\t  // doesn't expect a non-string/function type and can throw confusing errors.\n\t\t  // We don't want exception behavior to differ between dev and prod.\n\t\t  // (Rendering will throw with a helpful message and as soon as the type is\n\t\t  // fixed, the key warnings will appear.)\n\n\n\t\t  if (validType) {\n\t\t    for (var i = 2; i < arguments.length; i++) {\n\t\t      validateChildKeys(arguments[i], type);\n\t\t    }\n\t\t  }\n\n\t\t  if (type === REACT_FRAGMENT_TYPE) {\n\t\t    validateFragmentProps(element);\n\t\t  } else {\n\t\t    validatePropTypes(element);\n\t\t  }\n\n\t\t  return element;\n\t\t}\n\t\tvar didWarnAboutDeprecatedCreateFactory = false;\n\t\tfunction createFactoryWithValidation(type) {\n\t\t  var validatedFactory = createElementWithValidation.bind(null, type);\n\t\t  validatedFactory.type = type;\n\n\t\t  {\n\t\t    if (!didWarnAboutDeprecatedCreateFactory) {\n\t\t      didWarnAboutDeprecatedCreateFactory = true;\n\n\t\t      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n\t\t    } // Legacy hook: remove it\n\n\n\t\t    Object.defineProperty(validatedFactory, 'type', {\n\t\t      enumerable: false,\n\t\t      get: function () {\n\t\t        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n\n\t\t        Object.defineProperty(this, 'type', {\n\t\t          value: type\n\t\t        });\n\t\t        return type;\n\t\t      }\n\t\t    });\n\t\t  }\n\n\t\t  return validatedFactory;\n\t\t}\n\t\tfunction cloneElementWithValidation(element, props, children) {\n\t\t  var newElement = cloneElement.apply(this, arguments);\n\n\t\t  for (var i = 2; i < arguments.length; i++) {\n\t\t    validateChildKeys(arguments[i], newElement.type);\n\t\t  }\n\n\t\t  validatePropTypes(newElement);\n\t\t  return newElement;\n\t\t}\n\n\t\tfunction startTransition(scope, options) {\n\t\t  var prevTransition = ReactCurrentBatchConfig.transition;\n\t\t  ReactCurrentBatchConfig.transition = {};\n\t\t  var currentTransition = ReactCurrentBatchConfig.transition;\n\n\t\t  {\n\t\t    ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n\t\t  }\n\n\t\t  try {\n\t\t    scope();\n\t\t  } finally {\n\t\t    ReactCurrentBatchConfig.transition = prevTransition;\n\n\t\t    {\n\t\t      if (prevTransition === null && currentTransition._updatedFibers) {\n\t\t        var updatedFibersCount = currentTransition._updatedFibers.size;\n\n\t\t        if (updatedFibersCount > 10) {\n\t\t          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n\t\t        }\n\n\t\t        currentTransition._updatedFibers.clear();\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tvar didWarnAboutMessageChannel = false;\n\t\tvar enqueueTaskImpl = null;\n\t\tfunction enqueueTask(task) {\n\t\t  if (enqueueTaskImpl === null) {\n\t\t    try {\n\t\t      // read require off the module object to get around the bundlers.\n\t\t      // we don't want them to detect a require and bundle a Node polyfill.\n\t\t      var requireString = ('require' + Math.random()).slice(0, 7);\n\t\t      var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n\t\t      // version of setImmediate, bypassing fake timers if any.\n\n\t\t      enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n\t\t    } catch (_err) {\n\t\t      // we're in a browser\n\t\t      // we can't use regular timers because they may still be faked\n\t\t      // so we try MessageChannel+postMessage instead\n\t\t      enqueueTaskImpl = function (callback) {\n\t\t        {\n\t\t          if (didWarnAboutMessageChannel === false) {\n\t\t            didWarnAboutMessageChannel = true;\n\n\t\t            if (typeof MessageChannel === 'undefined') {\n\t\t              error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n\t\t            }\n\t\t          }\n\t\t        }\n\n\t\t        var channel = new MessageChannel();\n\t\t        channel.port1.onmessage = callback;\n\t\t        channel.port2.postMessage(undefined);\n\t\t      };\n\t\t    }\n\t\t  }\n\n\t\t  return enqueueTaskImpl(task);\n\t\t}\n\n\t\tvar actScopeDepth = 0;\n\t\tvar didWarnNoAwaitAct = false;\n\t\tfunction act(callback) {\n\t\t  {\n\t\t    // `act` calls can be nested, so we track the depth. This represents the\n\t\t    // number of `act` scopes on the stack.\n\t\t    var prevActScopeDepth = actScopeDepth;\n\t\t    actScopeDepth++;\n\n\t\t    if (ReactCurrentActQueue.current === null) {\n\t\t      // This is the outermost `act` scope. Initialize the queue. The reconciler\n\t\t      // will detect the queue and use it instead of Scheduler.\n\t\t      ReactCurrentActQueue.current = [];\n\t\t    }\n\n\t\t    var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n\t\t    var result;\n\n\t\t    try {\n\t\t      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n\t\t      // set to `true` while the given callback is executed, not for updates\n\t\t      // triggered during an async event, because this is how the legacy\n\t\t      // implementation of `act` behaved.\n\t\t      ReactCurrentActQueue.isBatchingLegacy = true;\n\t\t      result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n\t\t      // which flushed updates immediately after the scope function exits, even\n\t\t      // if it's an async function.\n\n\t\t      if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n\t\t        var queue = ReactCurrentActQueue.current;\n\n\t\t        if (queue !== null) {\n\t\t          ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n\t\t          flushActQueue(queue);\n\t\t        }\n\t\t      }\n\t\t    } catch (error) {\n\t\t      popActScope(prevActScopeDepth);\n\t\t      throw error;\n\t\t    } finally {\n\t\t      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n\t\t    }\n\n\t\t    if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n\t\t      var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n\t\t      // for it to resolve before exiting the current scope.\n\n\t\t      var wasAwaited = false;\n\t\t      var thenable = {\n\t\t        then: function (resolve, reject) {\n\t\t          wasAwaited = true;\n\t\t          thenableResult.then(function (returnValue) {\n\t\t            popActScope(prevActScopeDepth);\n\n\t\t            if (actScopeDepth === 0) {\n\t\t              // We've exited the outermost act scope. Recursively flush the\n\t\t              // queue until there's no remaining work.\n\t\t              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n\t\t            } else {\n\t\t              resolve(returnValue);\n\t\t            }\n\t\t          }, function (error) {\n\t\t            // The callback threw an error.\n\t\t            popActScope(prevActScopeDepth);\n\t\t            reject(error);\n\t\t          });\n\t\t        }\n\t\t      };\n\n\t\t      {\n\t\t        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n\t\t          // eslint-disable-next-line no-undef\n\t\t          Promise.resolve().then(function () {}).then(function () {\n\t\t            if (!wasAwaited) {\n\t\t              didWarnNoAwaitAct = true;\n\n\t\t              error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n\t\t            }\n\t\t          });\n\t\t        }\n\t\t      }\n\n\t\t      return thenable;\n\t\t    } else {\n\t\t      var returnValue = result; // The callback is not an async function. Exit the current scope\n\t\t      // immediately, without awaiting.\n\n\t\t      popActScope(prevActScopeDepth);\n\n\t\t      if (actScopeDepth === 0) {\n\t\t        // Exiting the outermost act scope. Flush the queue.\n\t\t        var _queue = ReactCurrentActQueue.current;\n\n\t\t        if (_queue !== null) {\n\t\t          flushActQueue(_queue);\n\t\t          ReactCurrentActQueue.current = null;\n\t\t        } // Return a thenable. If the user awaits it, we'll flush again in\n\t\t        // case additional work was scheduled by a microtask.\n\n\n\t\t        var _thenable = {\n\t\t          then: function (resolve, reject) {\n\t\t            // Confirm we haven't re-entered another `act` scope, in case\n\t\t            // the user does something weird like await the thenable\n\t\t            // multiple times.\n\t\t            if (ReactCurrentActQueue.current === null) {\n\t\t              // Recursively flush the queue until there's no remaining work.\n\t\t              ReactCurrentActQueue.current = [];\n\t\t              recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n\t\t            } else {\n\t\t              resolve(returnValue);\n\t\t            }\n\t\t          }\n\t\t        };\n\t\t        return _thenable;\n\t\t      } else {\n\t\t        // Since we're inside a nested `act` scope, the returned thenable\n\t\t        // immediately resolves. The outer scope will flush the queue.\n\t\t        var _thenable2 = {\n\t\t          then: function (resolve, reject) {\n\t\t            resolve(returnValue);\n\t\t          }\n\t\t        };\n\t\t        return _thenable2;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tfunction popActScope(prevActScopeDepth) {\n\t\t  {\n\t\t    if (prevActScopeDepth !== actScopeDepth - 1) {\n\t\t      error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n\t\t    }\n\n\t\t    actScopeDepth = prevActScopeDepth;\n\t\t  }\n\t\t}\n\n\t\tfunction recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n\t\t  {\n\t\t    var queue = ReactCurrentActQueue.current;\n\n\t\t    if (queue !== null) {\n\t\t      try {\n\t\t        flushActQueue(queue);\n\t\t        enqueueTask(function () {\n\t\t          if (queue.length === 0) {\n\t\t            // No additional work was scheduled. Finish.\n\t\t            ReactCurrentActQueue.current = null;\n\t\t            resolve(returnValue);\n\t\t          } else {\n\t\t            // Keep flushing work until there's none left.\n\t\t            recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n\t\t          }\n\t\t        });\n\t\t      } catch (error) {\n\t\t        reject(error);\n\t\t      }\n\t\t    } else {\n\t\t      resolve(returnValue);\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tvar isFlushing = false;\n\n\t\tfunction flushActQueue(queue) {\n\t\t  {\n\t\t    if (!isFlushing) {\n\t\t      // Prevent re-entrance.\n\t\t      isFlushing = true;\n\t\t      var i = 0;\n\n\t\t      try {\n\t\t        for (; i < queue.length; i++) {\n\t\t          var callback = queue[i];\n\n\t\t          do {\n\t\t            callback = callback(true);\n\t\t          } while (callback !== null);\n\t\t        }\n\n\t\t        queue.length = 0;\n\t\t      } catch (error) {\n\t\t        // If something throws, leave the remaining callbacks on the queue.\n\t\t        queue = queue.slice(i + 1);\n\t\t        throw error;\n\t\t      } finally {\n\t\t        isFlushing = false;\n\t\t      }\n\t\t    }\n\t\t  }\n\t\t}\n\n\t\tvar createElement$1 =  createElementWithValidation ;\n\t\tvar cloneElement$1 =  cloneElementWithValidation ;\n\t\tvar createFactory =  createFactoryWithValidation ;\n\t\tvar Children = {\n\t\t  map: mapChildren,\n\t\t  forEach: forEachChildren,\n\t\t  count: countChildren,\n\t\t  toArray: toArray,\n\t\t  only: onlyChild\n\t\t};\n\n\t\texports.Children = Children;\n\t\texports.Component = Component;\n\t\texports.Fragment = REACT_FRAGMENT_TYPE;\n\t\texports.Profiler = REACT_PROFILER_TYPE;\n\t\texports.PureComponent = PureComponent;\n\t\texports.StrictMode = REACT_STRICT_MODE_TYPE;\n\t\texports.Suspense = REACT_SUSPENSE_TYPE;\n\t\texports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n\t\texports.cloneElement = cloneElement$1;\n\t\texports.createContext = createContext;\n\t\texports.createElement = createElement$1;\n\t\texports.createFactory = createFactory;\n\t\texports.createRef = createRef;\n\t\texports.forwardRef = forwardRef;\n\t\texports.isValidElement = isValidElement;\n\t\texports.lazy = lazy;\n\t\texports.memo = memo;\n\t\texports.startTransition = startTransition;\n\t\texports.unstable_act = act;\n\t\texports.useCallback = useCallback;\n\t\texports.useContext = useContext;\n\t\texports.useDebugValue = useDebugValue;\n\t\texports.useDeferredValue = useDeferredValue;\n\t\texports.useEffect = useEffect;\n\t\texports.useId = useId;\n\t\texports.useImperativeHandle = useImperativeHandle;\n\t\texports.useInsertionEffect = useInsertionEffect;\n\t\texports.useLayoutEffect = useLayoutEffect;\n\t\texports.useMemo = useMemo;\n\t\texports.useReducer = useReducer;\n\t\texports.useRef = useRef;\n\t\texports.useState = useState;\n\t\texports.useSyncExternalStore = useSyncExternalStore;\n\t\texports.useTransition = useTransition;\n\t\texports.version = ReactVersion;\n\t\t          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\t\tif (\n\t\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n\t\t    'function'\n\t\t) {\n\t\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t\t}\n\t\t        \n\t\t  })();\n\t\t} \n\t} (react_development, react_development.exports));\n\treturn react_development.exports;\n}\n\nif (false) {} else {\n  react.exports = requireReact_development();\n}\n\nvar reactExports = react.exports;\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z$1 = \"/* Styling for the pill button */\\n\\n/* Import the Poppins font from Google Fonts */\\n@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap');\\n\\nbutton {\\n    display: inline-block;\\n    padding: 10px 20px; /* Adjust padding as needed */\\n    border: 2px solid #000; /* Black border */\\n    background-color: #008AFF; /* Deep blue background */\\n\\n    color: #FFF;\\n    text-align: center;\\n    font-family: Poppins, sans-serif;\\n    font-size: 16px;\\n    font-style: normal;\\n    font-weight: 500;\\n    line-height: normal;\\n\\n    text-decoration: none;\\n    cursor: pointer;\\n    transition: all 0.3s, color 200ms, border-color 0.3s;\\n    box-shadow: black -4px 4px 0;\\n    transform: translate(4px, -4px);\\n}\\n\\n/* Hover effect */\\nbutton:hover {\\n    border-color: #000; /* Black border on hover */\\n    color: #fff; /* White text color on hover */\\n    box-shadow: black 0px 0px 0;\\n    transform: translate(0px, 0px);\\n}\\n\\nicon {\\n    font-size: 24px; /* Adjust icon size as needed */\\n    margin-right: 10px; /* Adjust spacing between icon and text */\\n}\";\nstyleInject(css_248z$1);\n\nconst ConnectToTerraButton = (props) => {\n    return (reactExports.createElement(\"button\", { className: \"flex items-center justify-around bg-blue-500 hover:bg-blue-600 text-bold py-2 px-4 rounded-full transition duration-300 ease-in-out transform hover:scale-105 font-serif\", onClick: props.onClick },\n        reactExports.createElement(\"span\", null, \"Connect Wearable\"),\n        reactExports.createElement(\"svg\", { width: \"30\", height: \"15\", viewBox: \"0 0 20 20\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\" },\n            reactExports.createElement(\"path\", { d: \"M18 15L12 9L6 15\", stroke: \"white\", strokeWidth: \"2\", strokeLinecap: \"round\", strokeLinejoin: \"round\" }))));\n};\n\nvar css_248z = \"/* Styling for the pill button */\\n@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap');\\n\\nbutton {\\n    display: inline-block;\\n    padding: 10px 20px;\\n    border: 2px solid #000; /* Black border */\\n    background-color: #007bff; /* Deep blue background */\\n    color: #fff; /* White text color */\\n    border-radius: 50px; /* Pill shape */\\n    font-weight: bold;\\n    font-family: Poppins, sans-serif;\\n    font-size: 16px;\\n    text-align: center;\\n    text-decoration: none;\\n    cursor: pointer;\\n    transition: all 0.3s, color 200ms, border-color 0.3s;\\n    box-shadow: black -4px 4px 0;\\n    transform: translate(4px, -4px);\\n    justify-content: space-between\\n}\\n\\n/* Hover effect */\\nbutton:hover {\\n    border-color: #000; /* Black border on hover */\\n    color: #fff; /* White text color on hover */\\n    box-shadow: black 0px 0px 0;\\n    transform: translate(0px, 0px);\\n}\\n\\nimg {\\n    width: 15px;\\n    height: auto;\\n}\\n\\n.container {\\n    display: flex;\\n    justify-content: space-around; /* Distribute space evenly between children */\\n    align-items: center; /* Center vertically if needed */\\n    width: 100%;\\n}\";\nstyleInject(css_248z);\n\nvar Providers;\n(function (Providers) {\n    Providers[\"APPLE\"] = \"Apple Health\";\n    Providers[\"CONCEPT2\"] = \"Concept2\";\n    Providers[\"EIGHT\"] = \"Eight\";\n    Providers[\"FITBIT\"] = \"Fitbit\";\n    Providers[\"FREESTYLELIBRE\"] = \"FreeStyleLibre\";\n    Providers[\"GARMIN\"] = \"Garmin\";\n    Providers[\"GOOGLE\"] = \"Google\";\n    Providers[\"IFIT\"] = \"IFit\";\n    Providers[\"OURA\"] = \"Oura\";\n    Providers[\"PELOTON\"] = \"Peloton\";\n    Providers[\"POLAR\"] = \"Polar\";\n    Providers[\"SAMSUNG\"] = \"Samsung\";\n    Providers[\"SUUNTO\"] = \"Suunto\";\n    Providers[\"OMRON\"] = \"Omron\";\n    Providers[\"COROS\"] = \"Coros\";\n    Providers[\"TEMPO\"] = \"Tempo\";\n    Providers[\"TRAININGPEAKS\"] = \"TrainingPeaks\";\n    Providers[\"WAHOO\"] = \"Wahoo\";\n    Providers[\"WHOOP\"] = \"Whoop\";\n    Providers[\"WEAROS\"] = \"WearOS\";\n    Providers[\"WITHINGS\"] = \"Withings\";\n    Providers[\"ZWIFT\"] = \"Zwift\";\n    Providers[\"FATSECRET\"] = \"FatSecret\";\n    Providers[\"CRONOMETER\"] = \"Cronometer\";\n    Providers[\"MYFITNESSPAL\"] = \"MyFitnessPal\";\n    Providers[\"NUTRACHECK\"] = \"NutraCheck\";\n    Providers[\"UNDERARMOUR\"] = \"UnderArmour\";\n    Providers[\"GOOGLEFIT\"] = \"GoogleFit\";\n})(Providers || (Providers = {}));\nconst healthDataProviders = {\n    'FITBIT': Providers.FITBIT,\n    'GARMIN': Providers.GARMIN,\n    'APPLE': Providers.APPLE,\n    'CONCEPT2': Providers.CONCEPT2,\n    'EIGHT': Providers.EIGHT,\n    'FREESTYLELIBRE': Providers.FREESTYLELIBRE,\n    'GOOGLE': Providers.GOOGLE,\n    'IFIT': Providers.IFIT,\n    'OURA': Providers.OURA,\n    'PELOTON': Providers.PELOTON,\n    'POLAR': Providers.POLAR,\n    'SAMSUNG': Providers.SAMSUNG,\n    'SUUNTO': Providers.SUUNTO,\n    'OMRON': Providers.OMRON,\n    'COROS': Providers.COROS,\n    'TEMPO': Providers.TEMPO,\n    'TRAININGPEAKS': Providers.TRAININGPEAKS,\n    'WAHOO': Providers.WAHOO,\n    'WHOOP': Providers.WHOOP,\n    'WEAROS': Providers.WEAROS,\n    'WITHINGS': Providers.WITHINGS,\n    'ZWIFT': Providers.ZWIFT,\n    'FATSECRET': Providers.FATSECRET,\n    'CRONOMETER': Providers.CRONOMETER,\n    'MYFITNESSPAL': Providers.MYFITNESSPAL,\n    'NUTRACHECK': Providers.NUTRACHECK,\n    'UNDERARMOUR': Providers.UNDERARMOUR,\n    'GOOGLEFIT': Providers.GOOGLEFIT\n};\n// const providerIcons: { [key: string]: any } = {\n//     'FITBIT': FitbitIcon,\n//     'GARMIN': GarminIcon,\n//     'APPLE': AppleIcon,\n//     'CONCEPT2': Concept2Icon,\n//     'EIGHT': EightIcon,\n//     'FREESTYLELIBRE': FreeStyleLibreIcon,\n//     'GOOGLE': GoogleIcon,\n//     'IFIT': IFitIcon,\n//     'OURA': OuraIcon,\n//     'PELOTON': PelotonIcon,\n//     'POLAR': PolarIcon,\n//     'SAMSUNG': SamsungIcon,\n//     'SUUNTO': SuuntoIcon,\n//     'OMRON': OmronIcon,\n//     'COROS': CorosIcon,\n//     'TEMPO': TempoIcon,\n//     'TRAININGPEAKS': TrainingPeaksIcon,\n//     'WAHOO': WahooIcon,\n//     'WHOOP': WhoopIcon,\n//     'WITHINGS': WithingsIcon,\n//     'ZWIFT': ZwiftIcon,\n//     'FATSECRET': FatSecretIcon,\n//     'CRONOMETER': CronometerIcon,\n//     'MYFITNESSPAL': MyFitnessPalIcon,\n//     'NUTRACHECK': NutraCheckIcon,\n//     'UNDERARMOUR': UnderArmourIcon,\n// };\nconst ConnectToProviderButton = (props) => {\n    var _a;\n    const provider = (_a = props.provider) === null || _a === void 0 ? void 0 : _a.toUpperCase();\n    const selectedProvider = provider ? healthDataProviders[provider] : null;\n    // const selectedProviderIcon = provider ? providerIcons[provider] : null;\n    return (reactExports.createElement(\"button\", null,\n        reactExports.createElement(\"div\", { className: 'container' },\n            reactExports.createElement(\"span\", null, selectedProvider ? selectedProvider : '_____'))));\n};\n\nexports.ConnectToProvider = ConnectToProviderButton;\nexports.ConnectToTerraButton = ConnectToTerraButton;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRyeXRlcnJhL3RlcnJhLXVpL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFXQUFxVyxjQUFjLDZDQUE2QywyQkFBMkI7QUFDM2IsUUFBUSxxQkFBcUIsVUFBVSxnQ0FBZ0MsaUNBQWlDLDhCQUE4QixzQkFBc0Isa0JBQWtCLGFBQWEsZUFBZSxZQUFZLG1CQUFtQjtBQUN6TyxvQ0FBb0MsNExBQTRMLG9EQUFvRCxvQ0FBb0Msd0RBQXdELGNBQWMsd0JBQXdCLGtCQUFrQixhQUFhLGVBQWUsWUFBWSxtQkFBbUI7QUFDbmUsaUJBQWlCLGlCQUFpQiwwQkFBMEIseURBQXlELGFBQWEsSUFBSTtBQUN0SSxtQkFBbUIsVUFBVSxlQUFlLDRIQUE0SCx5QkFBeUIsc0JBQXNCLGFBQWEsdUJBQXVCLElBQUksd0JBQXdCLGNBQWMsNEVBQTRFLFFBQVE7QUFDelgsaUJBQWlCLFFBQVEsc0VBQXNFLGNBQWMscURBQXFELG1CQUFtQixPQUFPLG1CQUFtQix5Q0FBeUMsWUFBWSxFQUFFLGFBQWEsZ0JBQWdCO0FBQ25TLHVCQUF1QixlQUFlLHlDQUF5QyxTQUFTLGlCQUFpQixlQUFlLGlDQUFpQyxNQUFNLGlDQUFpQyxxQkFBcUIsbUhBQW1ILFNBQVMsMkdBQTJHLElBQUksbUJBQW1CLG9CQUFvQixXQUFXLEtBQUs7QUFDdmYsTUFBTSxlQUFlLGlCQUFpQix5REFBeUQsbUJBQW1CLHdDQUF3Qyx5SUFBeUksOEJBQThCLGtGQUFrRjtBQUNuWixtQkFBbUIsb0JBQW9CLGFBQWEsd0JBQXdCLHVCQUF1QixFQUFFLFNBQVMsY0FBYyxtQkFBbUIsZ0JBQWdCLE1BQU0sbUJBQW1CLDBEQUEwRCxhQUFhLDBEQUEwRCxFQUFFLDJDQUEyQywwQ0FBMEM7QUFDaFosUUFBUSxh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QUFXO0FBQ3hCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsR0FBRztBQUNoQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FB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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0VBQXNFOztBQUV0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLEdBQUc7QUFDaEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztB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QUN4cUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbXBsZS1uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9AdHJ5dGVycmEvdGVycmEtdWkvZGlzdC9janMvaW5kZXguanM/OWJiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciByZWFjdF9wcm9kdWN0aW9uX21pbiA9IHt9O1xuXG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBoYXNSZXF1aXJlZFJlYWN0X3Byb2R1Y3Rpb25fbWluO1xuXG5mdW5jdGlvbiByZXF1aXJlUmVhY3RfcHJvZHVjdGlvbl9taW4gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRSZWFjdF9wcm9kdWN0aW9uX21pbikgcmV0dXJuIHJlYWN0X3Byb2R1Y3Rpb25fbWluO1xuXHRoYXNSZXF1aXJlZFJlYWN0X3Byb2R1Y3Rpb25fbWluID0gMTtcbnZhciBsPVN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLG49U3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxwPVN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxxPVN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxyPVN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSx0PVN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSx1PVN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLHY9U3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLHc9U3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLHg9U3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIikseT1TeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSx6PVN5bWJvbC5pdGVyYXRvcjtmdW5jdGlvbiBBKGEpe2lmKG51bGw9PT1hfHxcIm9iamVjdFwiIT09dHlwZW9mIGEpcmV0dXJuIG51bGw7YT16JiZhW3pdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm4gXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YTpudWxsfVxuXHR2YXIgQj17aXNNb3VudGVkOmZ1bmN0aW9uKCl7cmV0dXJuICExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319LEM9T2JqZWN0LmFzc2lnbixEPXt9O2Z1bmN0aW9uIEUoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9RDt0aGlzLnVwZGF0ZXI9ZXx8Qjt9RS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTtcblx0RS5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxiKXtpZihcIm9iamVjdFwiIT09dHlwZW9mIGEmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhJiZudWxsIT1hKXRocm93IEVycm9yKFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIpO3RoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcyxhLGIsXCJzZXRTdGF0ZVwiKTt9O0UucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIik7fTtmdW5jdGlvbiBGKCl7fUYucHJvdG90eXBlPUUucHJvdG90eXBlO2Z1bmN0aW9uIEcoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9RDt0aGlzLnVwZGF0ZXI9ZXx8Qjt9dmFyIEg9Ry5wcm90b3R5cGU9bmV3IEY7XG5cdEguY29uc3RydWN0b3I9RztDKEgsRS5wcm90b3R5cGUpO0guaXNQdXJlUmVhY3RDb21wb25lbnQ9ITA7dmFyIEk9QXJyYXkuaXNBcnJheSxKPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksSz17Y3VycmVudDpudWxsfSxMPXtrZXk6ITAscmVmOiEwLF9fc2VsZjohMCxfX3NvdXJjZTohMH07XG5cdGZ1bmN0aW9uIE0oYSxiLGUpe3ZhciBkLGM9e30saz1udWxsLGg9bnVsbDtpZihudWxsIT1iKWZvcihkIGluIHZvaWQgMCE9PWIucmVmJiYoaD1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihrPVwiXCIrYi5rZXkpLGIpSi5jYWxsKGIsZCkmJiFMLmhhc093blByb3BlcnR5KGQpJiYoY1tkXT1iW2RdKTt2YXIgZz1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWcpYy5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxnKXtmb3IodmFyIGY9QXJyYXkoZyksbT0wO208ZzttKyspZlttXT1hcmd1bWVudHNbbSsyXTtjLmNoaWxkcmVuPWY7fWlmKGEmJmEuZGVmYXVsdFByb3BzKWZvcihkIGluIGc9YS5kZWZhdWx0UHJvcHMsZyl2b2lkIDA9PT1jW2RdJiYoY1tkXT1nW2RdKTtyZXR1cm4geyQkdHlwZW9mOmwsdHlwZTphLGtleTprLHJlZjpoLHByb3BzOmMsX293bmVyOksuY3VycmVudH19XG5cdGZ1bmN0aW9uIE4oYSxiKXtyZXR1cm4geyQkdHlwZW9mOmwsdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfX1mdW5jdGlvbiBPKGEpe3JldHVybiBcIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09bH1mdW5jdGlvbiBlc2NhcGUoYSl7dmFyIGI9e1wiPVwiOlwiPTBcIixcIjpcIjpcIj0yXCJ9O3JldHVybiBcIiRcIithLnJlcGxhY2UoL1s9Ol0vZyxmdW5jdGlvbihhKXtyZXR1cm4gYlthXX0pfXZhciBQPS9cXC8rL2c7ZnVuY3Rpb24gUShhLGIpe3JldHVybiBcIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoXCJcIithLmtleSk6Yi50b1N0cmluZygzNil9XG5cdGZ1bmN0aW9uIFIoYSxiLGUsZCxjKXt2YXIgaz10eXBlb2YgYTtpZihcInVuZGVmaW5lZFwiPT09a3x8XCJib29sZWFuXCI9PT1rKWE9bnVsbDt2YXIgaD0hMTtpZihudWxsPT09YSloPSEwO2Vsc2Ugc3dpdGNoKGspe2Nhc2UgXCJzdHJpbmdcIjpjYXNlIFwibnVtYmVyXCI6aD0hMDticmVhaztjYXNlIFwib2JqZWN0XCI6c3dpdGNoKGEuJCR0eXBlb2Ype2Nhc2UgbDpjYXNlIG46aD0hMDt9fWlmKGgpcmV0dXJuIGg9YSxjPWMoaCksYT1cIlwiPT09ZD9cIi5cIitRKGgsMCk6ZCxJKGMpPyhlPVwiXCIsbnVsbCE9YSYmKGU9YS5yZXBsYWNlKFAsXCIkJi9cIikrXCIvXCIpLFIoYyxiLGUsXCJcIixmdW5jdGlvbihhKXtyZXR1cm4gYX0pKTpudWxsIT1jJiYoTyhjKSYmKGM9TihjLGUrKCFjLmtleXx8aCYmaC5rZXk9PT1jLmtleT9cIlwiOihcIlwiK2Mua2V5KS5yZXBsYWNlKFAsXCIkJi9cIikrXCIvXCIpK2EpKSxiLnB1c2goYykpLDE7aD0wO2Q9XCJcIj09PWQ/XCIuXCI6ZCtcIjpcIjtpZihJKGEpKWZvcih2YXIgZz0wO2c8YS5sZW5ndGg7ZysrKXtrPVxuXHRhW2ddO3ZhciBmPWQrUShrLGcpO2grPVIoayxiLGUsZixjKTt9ZWxzZSBpZihmPUEoYSksXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGc9MDshKGs9YS5uZXh0KCkpLmRvbmU7KWs9ay52YWx1ZSxmPWQrUShrLGcrKyksaCs9UihrLGIsZSxmLGMpO2Vsc2UgaWYoXCJvYmplY3RcIj09PWspdGhyb3cgYj1TdHJpbmcoYSksRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiKyhcIltvYmplY3QgT2JqZWN0XVwiPT09Yj9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjpiKStcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIik7cmV0dXJuIGh9XG5cdGZ1bmN0aW9uIFMoYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGQ9W10sYz0wO1IoYSxkLFwiXCIsXCJcIixmdW5jdGlvbihhKXtyZXR1cm4gYi5jYWxsKGUsYSxjKyspfSk7cmV0dXJuIGR9ZnVuY3Rpb24gVChhKXtpZigtMT09PWEuX3N0YXR1cyl7dmFyIGI9YS5fcmVzdWx0O2I9YigpO2IudGhlbihmdW5jdGlvbihiKXtpZigwPT09YS5fc3RhdHVzfHwtMT09PWEuX3N0YXR1cylhLl9zdGF0dXM9MSxhLl9yZXN1bHQ9Yjt9LGZ1bmN0aW9uKGIpe2lmKDA9PT1hLl9zdGF0dXN8fC0xPT09YS5fc3RhdHVzKWEuX3N0YXR1cz0yLGEuX3Jlc3VsdD1iO30pOy0xPT09YS5fc3RhdHVzJiYoYS5fc3RhdHVzPTAsYS5fcmVzdWx0PWIpO31pZigxPT09YS5fc3RhdHVzKXJldHVybiBhLl9yZXN1bHQuZGVmYXVsdDt0aHJvdyBhLl9yZXN1bHQ7fVxuXHR2YXIgVT17Y3VycmVudDpudWxsfSxWPXt0cmFuc2l0aW9uOm51bGx9LFc9e1JlYWN0Q3VycmVudERpc3BhdGNoZXI6VSxSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzpWLFJlYWN0Q3VycmVudE93bmVyOkt9O3JlYWN0X3Byb2R1Y3Rpb25fbWluLkNoaWxkcmVuPXttYXA6Uyxmb3JFYWNoOmZ1bmN0aW9uKGEsYixlKXtTKGEsZnVuY3Rpb24oKXtiLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt9LGUpO30sY291bnQ6ZnVuY3Rpb24oYSl7dmFyIGI9MDtTKGEsZnVuY3Rpb24oKXtiKys7fSk7cmV0dXJuIGJ9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7cmV0dXJuIFMoYSxmdW5jdGlvbihhKXtyZXR1cm4gYX0pfHxbXX0sb25seTpmdW5jdGlvbihhKXtpZighTyhhKSl0aHJvdyBFcnJvcihcIlJlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLlwiKTtyZXR1cm4gYX19O3JlYWN0X3Byb2R1Y3Rpb25fbWluLkNvbXBvbmVudD1FO3JlYWN0X3Byb2R1Y3Rpb25fbWluLkZyYWdtZW50PXA7XG5cdHJlYWN0X3Byb2R1Y3Rpb25fbWluLlByb2ZpbGVyPXI7cmVhY3RfcHJvZHVjdGlvbl9taW4uUHVyZUNvbXBvbmVudD1HO3JlYWN0X3Byb2R1Y3Rpb25fbWluLlN0cmljdE1vZGU9cTtyZWFjdF9wcm9kdWN0aW9uX21pbi5TdXNwZW5zZT13O3JlYWN0X3Byb2R1Y3Rpb25fbWluLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEPVc7XG5cdHJlYWN0X3Byb2R1Y3Rpb25fbWluLmNsb25lRWxlbWVudD1mdW5jdGlvbihhLGIsZSl7aWYobnVsbD09PWF8fHZvaWQgMD09PWEpdGhyb3cgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIithK1wiLlwiKTt2YXIgZD1DKHt9LGEucHJvcHMpLGM9YS5rZXksaz1hLnJlZixoPWEuX293bmVyO2lmKG51bGwhPWIpe3ZvaWQgMCE9PWIucmVmJiYoaz1iLnJlZixoPUsuY3VycmVudCk7dm9pZCAwIT09Yi5rZXkmJihjPVwiXCIrYi5rZXkpO2lmKGEudHlwZSYmYS50eXBlLmRlZmF1bHRQcm9wcyl2YXIgZz1hLnR5cGUuZGVmYXVsdFByb3BzO2ZvcihmIGluIGIpSi5jYWxsKGIsZikmJiFMLmhhc093blByb3BlcnR5KGYpJiYoZFtmXT12b2lkIDA9PT1iW2ZdJiZ2b2lkIDAhPT1nP2dbZl06YltmXSk7fXZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZilkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGYpe2c9QXJyYXkoZik7XG5cdGZvcih2YXIgbT0wO208ZjttKyspZ1ttXT1hcmd1bWVudHNbbSsyXTtkLmNoaWxkcmVuPWc7fXJldHVybiB7JCR0eXBlb2Y6bCx0eXBlOmEudHlwZSxrZXk6YyxyZWY6ayxwcm9wczpkLF9vd25lcjpofX07cmVhY3RfcHJvZHVjdGlvbl9taW4uY3JlYXRlQ29udGV4dD1mdW5jdGlvbihhKXthPXskJHR5cGVvZjp1LF9jdXJyZW50VmFsdWU6YSxfY3VycmVudFZhbHVlMjphLF90aHJlYWRDb3VudDowLFByb3ZpZGVyOm51bGwsQ29uc3VtZXI6bnVsbCxfZGVmYXVsdFZhbHVlOm51bGwsX2dsb2JhbE5hbWU6bnVsbH07YS5Qcm92aWRlcj17JCR0eXBlb2Y6dCxfY29udGV4dDphfTtyZXR1cm4gYS5Db25zdW1lcj1hfTtyZWFjdF9wcm9kdWN0aW9uX21pbi5jcmVhdGVFbGVtZW50PU07cmVhY3RfcHJvZHVjdGlvbl9taW4uY3JlYXRlRmFjdG9yeT1mdW5jdGlvbihhKXt2YXIgYj1NLmJpbmQobnVsbCxhKTtiLnR5cGU9YTtyZXR1cm4gYn07cmVhY3RfcHJvZHVjdGlvbl9taW4uY3JlYXRlUmVmPWZ1bmN0aW9uKCl7cmV0dXJuIHtjdXJyZW50Om51bGx9fTtcblx0cmVhY3RfcHJvZHVjdGlvbl9taW4uZm9yd2FyZFJlZj1mdW5jdGlvbihhKXtyZXR1cm4geyQkdHlwZW9mOnYscmVuZGVyOmF9fTtyZWFjdF9wcm9kdWN0aW9uX21pbi5pc1ZhbGlkRWxlbWVudD1PO3JlYWN0X3Byb2R1Y3Rpb25fbWluLmxhenk9ZnVuY3Rpb24oYSl7cmV0dXJuIHskJHR5cGVvZjp5LF9wYXlsb2FkOntfc3RhdHVzOi0xLF9yZXN1bHQ6YX0sX2luaXQ6VH19O3JlYWN0X3Byb2R1Y3Rpb25fbWluLm1lbW89ZnVuY3Rpb24oYSxiKXtyZXR1cm4geyQkdHlwZW9mOngsdHlwZTphLGNvbXBhcmU6dm9pZCAwPT09Yj9udWxsOmJ9fTtyZWFjdF9wcm9kdWN0aW9uX21pbi5zdGFydFRyYW5zaXRpb249ZnVuY3Rpb24oYSl7dmFyIGI9Vi50cmFuc2l0aW9uO1YudHJhbnNpdGlvbj17fTt0cnl7YSgpO31maW5hbGx5e1YudHJhbnNpdGlvbj1iO319O3JlYWN0X3Byb2R1Y3Rpb25fbWluLnVuc3RhYmxlX2FjdD1mdW5jdGlvbigpe3Rocm93IEVycm9yKFwiYWN0KC4uLikgaXMgbm90IHN1cHBvcnRlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcyBvZiBSZWFjdC5cIik7fTtcblx0cmVhY3RfcHJvZHVjdGlvbl9taW4udXNlQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVS5jdXJyZW50LnVzZUNhbGxiYWNrKGEsYil9O3JlYWN0X3Byb2R1Y3Rpb25fbWluLnVzZUNvbnRleHQ9ZnVuY3Rpb24oYSl7cmV0dXJuIFUuY3VycmVudC51c2VDb250ZXh0KGEpfTtyZWFjdF9wcm9kdWN0aW9uX21pbi51c2VEZWJ1Z1ZhbHVlPWZ1bmN0aW9uKCl7fTtyZWFjdF9wcm9kdWN0aW9uX21pbi51c2VEZWZlcnJlZFZhbHVlPWZ1bmN0aW9uKGEpe3JldHVybiBVLmN1cnJlbnQudXNlRGVmZXJyZWRWYWx1ZShhKX07cmVhY3RfcHJvZHVjdGlvbl9taW4udXNlRWZmZWN0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIFUuY3VycmVudC51c2VFZmZlY3QoYSxiKX07cmVhY3RfcHJvZHVjdGlvbl9taW4udXNlSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gVS5jdXJyZW50LnVzZUlkKCl9O3JlYWN0X3Byb2R1Y3Rpb25fbWluLnVzZUltcGVyYXRpdmVIYW5kbGU9ZnVuY3Rpb24oYSxiLGUpe3JldHVybiBVLmN1cnJlbnQudXNlSW1wZXJhdGl2ZUhhbmRsZShhLGIsZSl9O1xuXHRyZWFjdF9wcm9kdWN0aW9uX21pbi51c2VJbnNlcnRpb25FZmZlY3Q9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVS5jdXJyZW50LnVzZUluc2VydGlvbkVmZmVjdChhLGIpfTtyZWFjdF9wcm9kdWN0aW9uX21pbi51c2VMYXlvdXRFZmZlY3Q9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVS5jdXJyZW50LnVzZUxheW91dEVmZmVjdChhLGIpfTtyZWFjdF9wcm9kdWN0aW9uX21pbi51c2VNZW1vPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFUuY3VycmVudC51c2VNZW1vKGEsYil9O3JlYWN0X3Byb2R1Y3Rpb25fbWluLnVzZVJlZHVjZXI9ZnVuY3Rpb24oYSxiLGUpe3JldHVybiBVLmN1cnJlbnQudXNlUmVkdWNlcihhLGIsZSl9O3JlYWN0X3Byb2R1Y3Rpb25fbWluLnVzZVJlZj1mdW5jdGlvbihhKXtyZXR1cm4gVS5jdXJyZW50LnVzZVJlZihhKX07cmVhY3RfcHJvZHVjdGlvbl9taW4udXNlU3RhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIFUuY3VycmVudC51c2VTdGF0ZShhKX07cmVhY3RfcHJvZHVjdGlvbl9taW4udXNlU3luY0V4dGVybmFsU3RvcmU9ZnVuY3Rpb24oYSxiLGUpe3JldHVybiBVLmN1cnJlbnQudXNlU3luY0V4dGVybmFsU3RvcmUoYSxiLGUpfTtcblx0cmVhY3RfcHJvZHVjdGlvbl9taW4udXNlVHJhbnNpdGlvbj1mdW5jdGlvbigpe3JldHVybiBVLmN1cnJlbnQudXNlVHJhbnNpdGlvbigpfTtyZWFjdF9wcm9kdWN0aW9uX21pbi52ZXJzaW9uPVwiMTguMi4wXCI7XG5cdHJldHVybiByZWFjdF9wcm9kdWN0aW9uX21pbjtcbn1cblxudmFyIHJlYWN0X2RldmVsb3BtZW50ID0ge2V4cG9ydHM6IHt9fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xucmVhY3RfZGV2ZWxvcG1lbnQuZXhwb3J0cztcblxudmFyIGhhc1JlcXVpcmVkUmVhY3RfZGV2ZWxvcG1lbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVSZWFjdF9kZXZlbG9wbWVudCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFJlYWN0X2RldmVsb3BtZW50KSByZXR1cm4gcmVhY3RfZGV2ZWxvcG1lbnQuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRSZWFjdF9kZXZlbG9wbWVudCA9IDE7XG5cdChmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG5cdFx0ICAoZnVuY3Rpb24oKSB7XG5cblx0XHQvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5cdFx0aWYgKFxuXHRcdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuXHRcdCAgICAnZnVuY3Rpb24nXG5cdFx0KSB7XG5cdFx0ICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcblx0XHR9XG5cdFx0ICAgICAgICAgIHZhciBSZWFjdFZlcnNpb24gPSAnMTguMi4wJztcblxuXHRcdC8vIEFUVEVOVElPTlxuXHRcdC8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcblx0XHQvLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG5cdFx0Ly8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG5cdFx0dmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcblx0XHR2YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcblx0XHR2YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG5cdFx0dmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuXHRcdHZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcblx0XHR2YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG5cdFx0dmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcblx0XHR2YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG5cdFx0dmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuXHRcdHZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG5cdFx0dmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcblx0XHR2YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xuXHRcdHZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuXHRcdHZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG5cdFx0dmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXHRcdGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuXHRcdCAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG5cdFx0ICAgIHJldHVybiBudWxsO1xuXHRcdCAgfVxuXG5cdFx0ICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cblx0XHQgIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cblx0XHQgKi9cblx0XHR2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcblx0XHQgIC8qKlxuXHRcdCAgICogQGludGVybmFsXG5cdFx0ICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG5cdFx0ICAgKi9cblx0XHQgIGN1cnJlbnQ6IG51bGxcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG5cdFx0ICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuXHRcdCAqL1xuXHRcdHZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcblx0XHQgIHRyYW5zaXRpb246IG51bGxcblx0XHR9O1xuXG5cdFx0dmFyIFJlYWN0Q3VycmVudEFjdFF1ZXVlID0ge1xuXHRcdCAgY3VycmVudDogbnVsbCxcblx0XHQgIC8vIFVzZWQgdG8gcmVwcm9kdWNlIGJlaGF2aW9yIG9mIGBiYXRjaGVkVXBkYXRlc2AgaW4gbGVnYWN5IG1vZGUuXG5cdFx0ICBpc0JhdGNoaW5nTGVnYWN5OiBmYWxzZSxcblx0XHQgIGRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlOiBmYWxzZVxuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cblx0XHQgKlxuXHRcdCAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcblx0XHQgKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG5cdFx0ICovXG5cdFx0dmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXHRcdCAgLyoqXG5cdFx0ICAgKiBAaW50ZXJuYWxcblx0XHQgICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cblx0XHQgICAqL1xuXHRcdCAgY3VycmVudDogbnVsbFxuXHRcdH07XG5cblx0XHR2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xuXHRcdHZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcblx0XHRmdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcblx0XHQgIHtcblx0XHQgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuXHRcdCAgfVxuXHRcdH1cblxuXHRcdHtcblx0XHQgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG5cdFx0ICAgIHtcblx0XHQgICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG5cdFx0ICAgIH1cblx0XHQgIH07IC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuXG5cblx0XHQgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuXHRcdCAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG5cdFx0ICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG5cdFx0ICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcblx0XHQgICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG5cdFx0ICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cblx0XHQgICAgaWYgKGltcGwpIHtcblx0XHQgICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG5cdFx0ICAgIH1cblxuXHRcdCAgICByZXR1cm4gc3RhY2s7XG5cdFx0ICB9O1xuXHRcdH1cblxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHR2YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxuXHRcdHZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcblx0XHR2YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxuXHRcdHZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG5cdFx0Ly8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuXHRcdC8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG5cdFx0dmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxuXHRcdHZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcblx0XHQgIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG5cdFx0ICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG5cdFx0ICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXJcblx0XHR9O1xuXG5cdFx0e1xuXHRcdCAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cdFx0ICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlO1xuXHRcdH1cblxuXHRcdC8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG5cdFx0Ly9cblx0XHQvLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuXHRcdC8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuXHRcdGZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG5cdFx0ICB7XG5cdFx0ICAgIHtcblx0XHQgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdFx0ICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0XHQgICAgICB9XG5cblx0XHQgICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuXHRcdCAge1xuXHRcdCAgICB7XG5cdFx0ICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcblx0XHQgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdFx0ICAgICAgfVxuXG5cdFx0ICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuXHRcdCAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG5cdFx0ICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cblx0XHQgIHtcblx0XHQgICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXHRcdCAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuXHRcdCAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG5cdFx0ICAgICAgZm9ybWF0ICs9ICclcyc7XG5cdFx0ICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuXHRcdCAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cblx0XHQgICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHQgICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuXHRcdCAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuXHRcdCAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcblx0XHQgICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuXHRcdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cblx0XHQgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcblx0XHQgIH1cblx0XHR9XG5cblx0XHR2YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cblx0XHRmdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuXHRcdCAge1xuXHRcdCAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG5cdFx0ICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcblx0XHQgICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG5cdFx0ICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcblx0XHQgICAgICByZXR1cm47XG5cdFx0ICAgIH1cblxuXHRcdCAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG5cdFx0ICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG5cdFx0ICB9XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuXHRcdCAqL1xuXG5cblx0XHR2YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG5cdFx0ICAvKipcblx0XHQgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cblx0XHQgICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cblx0XHQgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdCAgICogQHByb3RlY3RlZFxuXHRcdCAgICogQGZpbmFsXG5cdFx0ICAgKi9cblx0XHQgIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG5cdFx0ICAgIHJldHVybiBmYWxzZTtcblx0XHQgIH0sXG5cblx0XHQgIC8qKlxuXHRcdCAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuXHRcdCAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG5cdFx0ICAgKlxuXHRcdCAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuXHRcdCAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG5cdFx0ICAgKlxuXHRcdCAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuXHRcdCAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cblx0XHQgICAqXG5cdFx0ICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cblx0XHQgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG5cdFx0ICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cblx0XHQgICAqIEBpbnRlcm5hbFxuXHRcdCAgICovXG5cdFx0ICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcblx0XHQgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuXHRcdCAgfSxcblxuXHRcdCAgLyoqXG5cdFx0ICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG5cdFx0ICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG5cdFx0ICAgKlxuXHRcdCAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cblx0XHQgICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG5cdFx0ICAgKlxuXHRcdCAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG5cdFx0ICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuXHRcdCAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cblx0XHQgICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuXHRcdCAgICogQGludGVybmFsXG5cdFx0ICAgKi9cblx0XHQgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcblx0XHQgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblx0XHQgIH0sXG5cblx0XHQgIC8qKlxuXHRcdCAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG5cdFx0ICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcblx0XHQgICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuXHRcdCAgICogZHVyaW5nIHRoZSBtZXJnZS5cblx0XHQgICAqXG5cdFx0ICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cblx0XHQgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuXHRcdCAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cblx0XHQgICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cblx0XHQgICAqIEBpbnRlcm5hbFxuXHRcdCAgICovXG5cdFx0ICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuXHRcdCAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG5cdFx0ICB9XG5cdFx0fTtcblxuXHRcdHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG5cdFx0dmFyIGVtcHR5T2JqZWN0ID0ge307XG5cblx0XHR7XG5cdFx0ICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG5cdFx0ICovXG5cblxuXHRcdGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuXHRcdCAgdGhpcy5wcm9wcyA9IHByb3BzO1xuXHRcdCAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cblx0XHQgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuXHRcdCAgLy8gcmVuZGVyZXIuXG5cblx0XHQgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cdFx0fVxuXG5cdFx0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cdFx0LyoqXG5cdFx0ICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcblx0XHQgKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuXHRcdCAqXG5cdFx0ICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cblx0XHQgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuXHRcdCAqXG5cdFx0ICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuXHRcdCAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuXHRcdCAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG5cdFx0ICogY29tcGxldGVkLlxuXHRcdCAqXG5cdFx0ICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG5cdFx0ICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG5cdFx0ICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcblx0XHQgKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuXHRcdCAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG5cdFx0ICogYXNzaWduZWQgdG8gdGhpcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG5cdFx0ICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG5cdFx0ICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuXHRcdCAqIEBmaW5hbFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblxuXHRcdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuXHRcdCAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgIT09ICdvYmplY3QnICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgIT09ICdmdW5jdGlvbicgJiYgcGFydGlhbFN0YXRlICE9IG51bGwpIHtcblx0XHQgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhICcgKyAnZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpO1xuXHRcdCAgfVxuXG5cdFx0ICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuXHRcdCAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuXHRcdCAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuXHRcdCAqXG5cdFx0ICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuXHRcdCAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cblx0XHQgKiBAZmluYWxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cblxuXHRcdENvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHQgIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuXHRcdCAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG5cdFx0ICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG5cdFx0ICovXG5cblxuXHRcdHtcblx0XHQgIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcblx0XHQgICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuXHRcdCAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuXHRcdCAgfTtcblxuXHRcdCAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG5cdFx0ICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG5cdFx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfSk7XG5cdFx0ICB9O1xuXG5cdFx0ICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcblx0XHQgICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcblx0XHQgICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcblx0XHQgICAgfVxuXHRcdCAgfVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cblxuXHRcdENvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cdFx0LyoqXG5cdFx0ICogQ29udmVuaWVuY2UgY29tcG9uZW50IHdpdGggZGVmYXVsdCBzaGFsbG93IGVxdWFsaXR5IGNoZWNrIGZvciBzQ1UuXG5cdFx0ICovXG5cblx0XHRmdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG5cdFx0ICB0aGlzLnByb3BzID0gcHJvcHM7XG5cdFx0ICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuXHRcdCAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG5cdFx0ICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXHRcdH1cblxuXHRcdHZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcblx0XHRwdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDsgLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5cblx0XHRhc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5cdFx0cHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cblx0XHQvLyBhbiBpbW11dGFibGUgb2JqZWN0IHdpdGggYSBzaW5nbGUgbXV0YWJsZSB2YWx1ZVxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcblx0XHQgIHZhciByZWZPYmplY3QgPSB7XG5cdFx0ICAgIGN1cnJlbnQ6IG51bGxcblx0XHQgIH07XG5cblx0XHQgIHtcblx0XHQgICAgT2JqZWN0LnNlYWwocmVmT2JqZWN0KTtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIHJlZk9iamVjdDtcblx0XHR9XG5cblx0XHR2YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cblx0XHRmdW5jdGlvbiBpc0FycmF5KGEpIHtcblx0XHQgIHJldHVybiBpc0FycmF5SW1wbChhKTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuXHRcdCAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG5cdFx0ICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuXHRcdCAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuXHRcdCAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG5cdFx0ICovXG5cdFx0Ly8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblx0XHRmdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuXHRcdCAge1xuXHRcdCAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG5cdFx0ICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuXHRcdCAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0Jztcblx0XHQgICAgcmV0dXJuIHR5cGU7XG5cdFx0ICB9XG5cdFx0fSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cblx0XHRmdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuXHRcdCAge1xuXHRcdCAgICB0cnkge1xuXHRcdCAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG5cdFx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICB9IGNhdGNoIChlKSB7XG5cdFx0ICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcblx0XHQgIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuXHRcdCAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcblx0XHQgIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cblx0XHQgIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuXHRcdCAgLy9cblx0XHQgIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuXHRcdCAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcblx0XHQgIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuXHRcdCAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG5cdFx0ICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cblx0XHQgIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG5cdFx0ICAvL1xuXHRcdCAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuXHRcdCAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuXHRcdCAgLy9cblx0XHQgIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG5cdFx0ICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcblx0XHQgIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcblx0XHQgIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG5cdFx0ICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG5cdFx0ICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG5cdFx0ICAvL1xuXHRcdCAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cdFx0ICByZXR1cm4gJycgKyB2YWx1ZTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuXHRcdCAge1xuXHRcdCAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG5cdFx0ICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuXHRcdCAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuXHRcdCAgICB9XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG5cdFx0ICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cblx0XHQgIGlmIChkaXNwbGF5TmFtZSkge1xuXHRcdCAgICByZXR1cm4gZGlzcGxheU5hbWU7XG5cdFx0ICB9XG5cblx0XHQgIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG5cdFx0ICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xuXHRcdH0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuXHRcdGZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcblx0XHQgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcblx0XHR9IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcblx0XHQgIGlmICh0eXBlID09IG51bGwpIHtcblx0XHQgICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG5cdFx0ICAgIHJldHVybiBudWxsO1xuXHRcdCAgfVxuXG5cdFx0ICB7XG5cdFx0ICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG5cdFx0ICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblx0XHQgICAgfVxuXHRcdCAgfVxuXG5cdFx0ICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHQgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG5cdFx0ICB9XG5cblx0XHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHQgICAgcmV0dXJuIHR5cGU7XG5cdFx0ICB9XG5cblx0XHQgIHN3aXRjaCAodHlwZSkge1xuXHRcdCAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG5cdFx0ICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cblx0XHQgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcblx0XHQgICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cblx0XHQgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuXHRcdCAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG5cdFx0ICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcblx0XHQgICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG5cdFx0ICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcblx0XHQgICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuXHRcdCAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcblx0XHQgICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cblx0XHQgIH1cblxuXHRcdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuXHRcdCAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcblx0XHQgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcblx0XHQgICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblx0XHQgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG5cdFx0ICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuXHRcdCAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcblx0XHQgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuXHRcdCAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcblx0XHQgICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuXHRcdCAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuXHRcdCAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuXHRcdCAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuXHRcdCAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuXHRcdCAgICAgICAgfVxuXG5cdFx0ICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG5cdFx0ICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG5cdFx0ICAgICAgICB7XG5cdFx0ICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcblx0XHQgICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuXHRcdCAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cblx0XHQgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuXHRcdCAgICAgICAgICB9IGNhdGNoICh4KSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdFx0ICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblxuXHRcdCAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXHRcdCAgICB9XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0XHR2YXIgUkVTRVJWRURfUFJPUFMgPSB7XG5cdFx0ICBrZXk6IHRydWUsXG5cdFx0ICByZWY6IHRydWUsXG5cdFx0ICBfX3NlbGY6IHRydWUsXG5cdFx0ICBfX3NvdXJjZTogdHJ1ZVxuXHRcdH07XG5cdFx0dmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxuXHRcdHtcblx0XHQgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcblx0XHQgIHtcblx0XHQgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcblx0XHQgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cblx0XHQgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuXHRcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuXHRcdCAge1xuXHRcdCAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuXHRcdCAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuXHRcdCAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG5cdFx0ICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICB7XG5cdFx0ICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuXHRcdCAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG5cdFx0ICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICB9O1xuXG5cdFx0ICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuXHRcdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuXHRcdCAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcblx0XHQgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICB9KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcblx0XHQgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIHtcblx0XHQgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG5cdFx0ICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cblx0XHQgICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgIH07XG5cblx0XHQgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG5cdFx0ICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG5cdFx0ICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuXHRcdCAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgIH0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcblx0XHQgIHtcblx0XHQgICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcblx0XHQgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpO1xuXG5cdFx0ICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG5cdFx0ICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuXHRcdCAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICB9XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG5cdFx0ICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcblx0XHQgKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcblx0XHQgKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsqfSB0eXBlXG5cdFx0ICogQHBhcmFtIHsqfSBwcm9wc1xuXHRcdCAqIEBwYXJhbSB7Kn0ga2V5XG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcblx0XHQgKiBAcGFyYW0geyp9IG93bmVyXG5cdFx0ICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG5cdFx0ICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuXHRcdCAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG5cdFx0ICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuXHRcdCAqIGNoYW5nZSBpbiBiZWhhdmlvci5cblx0XHQgKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcblx0XHQgKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqL1xuXG5cblx0XHR2YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuXHRcdCAgdmFyIGVsZW1lbnQgPSB7XG5cdFx0ICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuXHRcdCAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXHRcdCAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG5cdFx0ICAgIHR5cGU6IHR5cGUsXG5cdFx0ICAgIGtleToga2V5LFxuXHRcdCAgICByZWY6IHJlZixcblx0XHQgICAgcHJvcHM6IHByb3BzLFxuXHRcdCAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuXHRcdCAgICBfb3duZXI6IG93bmVyXG5cdFx0ICB9O1xuXG5cdFx0ICB7XG5cdFx0ICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cblx0XHQgICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cblx0XHQgICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuXHRcdCAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cblx0XHQgICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2Vcblx0XHQgICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuXHRcdCAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuXHRcdCAgICAvLyBpZ25vcmVzIGl0LlxuXG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcblx0XHQgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdCAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdCAgICAgIHdyaXRhYmxlOiB0cnVlLFxuXHRcdCAgICAgIHZhbHVlOiBmYWxzZVxuXHRcdCAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG5cdFx0ICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHQgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHQgICAgICB3cml0YWJsZTogZmFsc2UsXG5cdFx0ICAgICAgdmFsdWU6IHNlbGZcblx0XHQgICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG5cdFx0ICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcblx0XHQgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdCAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdCAgICAgIHdyaXRhYmxlOiBmYWxzZSxcblx0XHQgICAgICB2YWx1ZTogc291cmNlXG5cdFx0ICAgIH0pO1xuXG5cdFx0ICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG5cdFx0ICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcblx0XHQgICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiBlbGVtZW50O1xuXHRcdH07XG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuXHRcdCAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuXHRcdCAqL1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG5cdFx0ICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXHRcdCAgdmFyIHByb3BzID0ge307XG5cdFx0ICB2YXIga2V5ID0gbnVsbDtcblx0XHQgIHZhciByZWYgPSBudWxsO1xuXHRcdCAgdmFyIHNlbGYgPSBudWxsO1xuXHRcdCAgdmFyIHNvdXJjZSA9IG51bGw7XG5cblx0XHQgIGlmIChjb25maWcgIT0gbnVsbCkge1xuXHRcdCAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuXHRcdCAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cblx0XHQgICAgICB7XG5cdFx0ICAgICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblxuXHRcdCAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuXHRcdCAgICAgIHtcblx0XHQgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG5cdFx0ICAgICAgfVxuXG5cdFx0ICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuXHRcdCAgICB9XG5cblx0XHQgICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuXHRcdCAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXHRcdCAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuXHRcdCAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcblx0XHQgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cblx0XHQgIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cblx0XHQgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG5cdFx0ICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcblx0XHQgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0XHQgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG5cdFx0ICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG5cdFx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuXHRcdCAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuXHRcdCAgICB9XG5cblx0XHQgICAge1xuXHRcdCAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG5cdFx0ICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXG5cdFx0ICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcblx0XHQgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuXHRcdCAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcblx0XHQgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG5cdFx0ICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG5cdFx0ICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgfVxuXG5cdFx0ICB7XG5cdFx0ICAgIGlmIChrZXkgfHwgcmVmKSB7XG5cdFx0ICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG5cdFx0ICAgICAgaWYgKGtleSkge1xuXHRcdCAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcblx0XHQgICAgICB9XG5cblx0XHQgICAgICBpZiAocmVmKSB7XG5cdFx0ICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuXHRcdCAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblx0XHQgIHJldHVybiBuZXdFbGVtZW50O1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cblx0XHQgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuXHRcdCAqL1xuXG5cdFx0ZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcblx0XHQgIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIik7XG5cdFx0ICB9XG5cblx0XHQgIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG5cdFx0ICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblx0XHQgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcblx0XHQgIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuXHRcdCAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG5cdFx0ICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG5cdFx0ICAvLyB0cnVlIG93bmVyLlxuXG5cdFx0ICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cblx0XHQgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG5cdFx0ICBpZiAoY29uZmlnICE9IG51bGwpIHtcblx0XHQgICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcblx0XHQgICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cblx0XHQgICAgICByZWYgPSBjb25maWcucmVmO1xuXHRcdCAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG5cdFx0ICAgICAge1xuXHRcdCAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcblx0XHQgICAgICB9XG5cblx0XHQgICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG5cdFx0ICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG5cdFx0ICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cblx0XHQgICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG5cdFx0ICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcblx0XHQgICAgfVxuXG5cdFx0ICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG5cdFx0ICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuXHRcdCAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblx0XHQgICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcblx0XHQgICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cblx0XHQgIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cblx0XHQgIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG5cdFx0ICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcblx0XHQgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0XHQgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG5cdFx0ICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG5cdFx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuXHRcdCAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuXHRcdCAgICB9XG5cblx0XHQgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cblx0XHQgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG5cdFx0ICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3Rcblx0XHQgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuXHRcdCAqIEBmaW5hbFxuXHRcdCAqL1xuXG5cdFx0ZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG5cdFx0ICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXHRcdH1cblxuXHRcdHZhciBTRVBBUkFUT1IgPSAnLic7XG5cdFx0dmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcblx0XHQvKipcblx0XHQgKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuXHRcdCAqL1xuXG5cdFx0ZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuXHRcdCAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcblx0XHQgIHZhciBlc2NhcGVyTG9va3VwID0ge1xuXHRcdCAgICAnPSc6ICc9MCcsXG5cdFx0ICAgICc6JzogJz0yJ1xuXHRcdCAgfTtcblx0XHQgIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuXHRcdCAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG5cdFx0ICB9KTtcblx0XHQgIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcblx0XHQgKiBwYXR0ZXJuLlxuXHRcdCAqL1xuXG5cblx0XHR2YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXHRcdHZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cblx0XHRmdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuXHRcdCAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ31cblx0XHQgKi9cblxuXG5cdFx0ZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuXHRcdCAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcblx0XHQgIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuXHRcdCAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcblx0XHQgICAgLy8gRXhwbGljaXQga2V5XG5cdFx0ICAgIHtcblx0XHQgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGVsZW1lbnQua2V5KTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG5cdFx0ICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuXHRcdCAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG5cdFx0ICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuXHRcdCAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuXHRcdCAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cblx0XHQgICAgY2hpbGRyZW4gPSBudWxsO1xuXHRcdCAgfVxuXG5cdFx0ICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuXHRcdCAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG5cdFx0ICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcblx0XHQgIH0gZWxzZSB7XG5cdFx0ICAgIHN3aXRjaCAodHlwZSkge1xuXHRcdCAgICAgIGNhc2UgJ3N0cmluZyc6XG5cdFx0ICAgICAgY2FzZSAnbnVtYmVyJzpcblx0XHQgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcblx0XHQgICAgICAgIGJyZWFrO1xuXG5cdFx0ICAgICAgY2FzZSAnb2JqZWN0Jzpcblx0XHQgICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcblx0XHQgICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG5cdFx0ICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG5cdFx0ICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuXHRcdCAgICAgICAgfVxuXG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG5cdFx0ICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcblx0XHQgICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcblx0XHQgICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuXHRcdCAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG5cdFx0ICAgIGlmIChpc0FycmF5KG1hcHBlZENoaWxkKSkge1xuXHRcdCAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuXHRcdCAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG5cdFx0ICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuXHRcdCAgICAgIH1cblxuXHRcdCAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG5cdFx0ICAgICAgICByZXR1cm4gYztcblx0XHQgICAgICB9KTtcblx0XHQgICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG5cdFx0ICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuXHRcdCAgICAgICAge1xuXHRcdCAgICAgICAgICAvLyBUaGUgYGlmYCBzdGF0ZW1lbnQgaGVyZSBwcmV2ZW50cyBhdXRvLWRpc2FibGluZyBvZiB0aGUgc2FmZVxuXHRcdCAgICAgICAgICAvLyBjb2VyY2lvbiBFU0xpbnQgcnVsZSwgc28gd2UgbXVzdCBtYW51YWxseSBkaXNhYmxlIGl0IGJlbG93LlxuXHRcdCAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcblx0XHQgICAgICAgICAgaWYgKG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpKSB7XG5cdFx0ICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXBwZWRDaGlsZC5rZXkpO1xuXHRcdCAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cblx0XHQgICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuXHRcdCAgICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG5cdFx0ICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcblx0XHQgICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuXHRcdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cdFx0ICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuXHRcdCAgICAgIH1cblxuXHRcdCAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuXHRcdCAgICB9XG5cblx0XHQgICAgcmV0dXJuIDE7XG5cdFx0ICB9XG5cblx0XHQgIHZhciBjaGlsZDtcblx0XHQgIHZhciBuZXh0TmFtZTtcblx0XHQgIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG5cdFx0ICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG5cdFx0ICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdCAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0ICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuXHRcdCAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuXHRcdCAgICB9XG5cdFx0ICB9IGVsc2Uge1xuXHRcdCAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG5cdFx0ICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cblx0XHQgICAgICB7XG5cdFx0ICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblx0XHQgICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcblx0XHQgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG5cdFx0ICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG5cdFx0ICAgICAgICAgIH1cblxuXHRcdCAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9XG5cblx0XHQgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG5cdFx0ICAgICAgdmFyIHN0ZXA7XG5cdFx0ICAgICAgdmFyIGlpID0gMDtcblxuXHRcdCAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcblx0XHQgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcblx0XHQgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcblx0XHQgICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuXHRcdCAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXHRcdCAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG5cdFx0ICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcblx0XHQgICAgfVxuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gc3VidHJlZUNvdW50O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuXHRcdCAqXG5cdFx0ICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG5cdFx0ICpcblx0XHQgKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuXHRcdCAqIGxlYWYgY2hpbGQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cblx0XHQgKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG5cdFx0ICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuXHRcdCAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcblx0XHQgICAgcmV0dXJuIGNoaWxkcmVuO1xuXHRcdCAgfVxuXG5cdFx0ICB2YXIgcmVzdWx0ID0gW107XG5cdFx0ICB2YXIgY291bnQgPSAwO1xuXHRcdCAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0ICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuXHRcdCAgfSk7XG5cdFx0ICByZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcblx0XHQgKiBgcHJvcHMuY2hpbGRyZW5gLlxuXHRcdCAqXG5cdFx0ICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuXHRcdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cblx0XHQgKi9cblxuXG5cdFx0ZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuXHRcdCAgdmFyIG4gPSAwO1xuXHRcdCAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcblx0XHQgICAgbisrOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmdcblx0XHQgIH0pO1xuXHRcdCAgcmV0dXJuIG47XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG5cdFx0ICpcblx0XHQgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG5cdFx0ICpcblx0XHQgKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuXHRcdCAqIGxlYWYgY2hpbGQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG5cdFx0ICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuXHRcdCAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZm9yRWFjaEZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nLlxuXHRcdCAgfSwgZm9yRWFjaENvbnRleHQpO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuXHRcdCAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG5cdFx0ICpcblx0XHQgKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG5cdFx0ICovXG5cblxuXHRcdGZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcblx0XHQgIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG5cdFx0ICAgIHJldHVybiBjaGlsZDtcblx0XHQgIH0pIHx8IFtdO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcblx0XHQgKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcblx0XHQgKlxuXHRcdCAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcblx0XHQgKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuXHRcdCAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cblx0XHQgKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG5cdFx0ICogc3RydWN0dXJlLlxuXHRcdCAqL1xuXG5cblx0XHRmdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcblx0XHQgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG5cdFx0ICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJyk7XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiBjaGlsZHJlbjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuXHRcdCAgLy8gVE9ETzogU2Vjb25kIGFyZ3VtZW50IHVzZWQgdG8gYmUgYW4gb3B0aW9uYWwgYGNhbGN1bGF0ZUNoYW5nZWRCaXRzYFxuXHRcdCAgLy8gZnVuY3Rpb24uIFdhcm4gdG8gcmVzZXJ2ZSBmb3IgZnV0dXJlIHVzZT9cblx0XHQgIHZhciBjb250ZXh0ID0ge1xuXHRcdCAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuXHRcdCAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuXHRcdCAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuXHRcdCAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcblx0XHQgICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG5cdFx0ICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuXHRcdCAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG5cdFx0ICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG5cdFx0ICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuXHRcdCAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cblx0XHQgICAgX3RocmVhZENvdW50OiAwLFxuXHRcdCAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcblx0XHQgICAgUHJvdmlkZXI6IG51bGwsXG5cdFx0ICAgIENvbnN1bWVyOiBudWxsLFxuXHRcdCAgICAvLyBBZGQgdGhlc2UgdG8gdXNlIHNhbWUgaGlkZGVuIGNsYXNzIGluIFZNIGFzIFNlcnZlckNvbnRleHRcblx0XHQgICAgX2RlZmF1bHRWYWx1ZTogbnVsbCxcblx0XHQgICAgX2dsb2JhbE5hbWU6IG51bGxcblx0XHQgIH07XG5cdFx0ICBjb250ZXh0LlByb3ZpZGVyID0ge1xuXHRcdCAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcblx0XHQgICAgX2NvbnRleHQ6IGNvbnRleHRcblx0XHQgIH07XG5cdFx0ICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcblx0XHQgIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuXHRcdCAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cblx0XHQgIHtcblx0XHQgICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuXHRcdCAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcblx0XHQgICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG5cdFx0ICAgIHZhciBDb25zdW1lciA9IHtcblx0XHQgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuXHRcdCAgICAgIF9jb250ZXh0OiBjb250ZXh0XG5cdFx0ICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuXHRcdCAgICAgIFByb3ZpZGVyOiB7XG5cdFx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuXHRcdCAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuXHRcdCAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG5cdFx0ICAgICAgICAgIH1cblxuXHRcdCAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcblx0XHQgICAgICAgIH0sXG5cdFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcblx0XHQgICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9LFxuXHRcdCAgICAgIF9jdXJyZW50VmFsdWU6IHtcblx0XHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcblx0XHQgICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9LFxuXHRcdCAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG5cdFx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcblx0XHQgICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgIH0sXG5cdFx0ICAgICAgX3RocmVhZENvdW50OiB7XG5cdFx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuXHRcdCAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9LFxuXHRcdCAgICAgIENvbnN1bWVyOiB7XG5cdFx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuXHRcdCAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuXHRcdCAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG5cdFx0ICAgICAgICAgIH1cblxuXHRcdCAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9LFxuXHRcdCAgICAgIGRpc3BsYXlOYW1lOiB7XG5cdFx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGlzcGxheU5hbWU7XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcblx0XHQgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lcikge1xuXHRcdCAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuXHRcdCAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcblx0XHQgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgIH1cblx0XHQgICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG5cdFx0ICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcblx0XHQgIH1cblxuXHRcdCAge1xuXHRcdCAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuXHRcdCAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIGNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0dmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcblx0XHR2YXIgUGVuZGluZyA9IDA7XG5cdFx0dmFyIFJlc29sdmVkID0gMTtcblx0XHR2YXIgUmVqZWN0ZWQgPSAyO1xuXG5cdFx0ZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcblx0XHQgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcblx0XHQgICAgdmFyIGN0b3IgPSBwYXlsb2FkLl9yZXN1bHQ7XG5cdFx0ICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblx0XHQgICAgLy8gVGhpcyBtaWdodCB0aHJvdyBlaXRoZXIgYmVjYXVzZSBpdCdzIG1pc3Npbmcgb3IgdGhyb3dzLiBJZiBzbywgd2UgdHJlYXQgaXRcblx0XHQgICAgLy8gYXMgc3RpbGwgdW5pbml0aWFsaXplZCBhbmQgdHJ5IGFnYWluIG5leHQgdGltZS4gV2hpY2ggaXMgdGhlIHNhbWUgYXMgd2hhdFxuXHRcdCAgICAvLyBoYXBwZW5zIGlmIHRoZSBjdG9yIG9yIGFueSB3cmFwcGVycyBwcm9jZXNzaW5nIHRoZSBjdG9yIHRocm93cy4gVGhpcyBtaWdodFxuXHRcdCAgICAvLyBlbmQgdXAgZml4aW5nIGl0IGlmIHRoZSByZXNvbHV0aW9uIHdhcyBhIGNvbmN1cnJlbmN5IGJ1Zy5cblxuXHRcdCAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcblx0XHQgICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nIHx8IHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuXHRcdCAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblx0XHQgICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG5cdFx0ICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG5cdFx0ICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0O1xuXHRcdCAgICAgIH1cblx0XHQgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0ICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcblx0XHQgICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cdFx0ICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuXHRcdCAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuXHRcdCAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfSk7XG5cblx0XHQgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuXHRcdCAgICAgIC8vIEluIGNhc2UsIHdlJ3JlIHN0aWxsIHVuaW5pdGlhbGl6ZWQsIHRoZW4gd2UncmUgd2FpdGluZyBmb3IgdGhlIHRoZW5hYmxlXG5cdFx0ICAgICAgLy8gdG8gcmVzb2x2ZS4gU2V0IGl0IGFzIHBlbmRpbmcgaW4gdGhlIG1lYW50aW1lLlxuXHRcdCAgICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcblx0XHQgICAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuXHRcdCAgICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cblx0XHQgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG5cdFx0ICAgIHZhciBtb2R1bGVPYmplY3QgPSBwYXlsb2FkLl9yZXN1bHQ7XG5cblx0XHQgICAge1xuXHRcdCAgICAgIGlmIChtb2R1bGVPYmplY3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcCcgKyAnb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuXHRcdCAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcXG5cXG5cIiArICdEaWQgeW91IGFjY2lkZW50YWxseSBwdXQgY3VybHkgYnJhY2VzIGFyb3VuZCB0aGUgaW1wb3J0PycsIG1vZHVsZU9iamVjdCk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cblx0XHQgICAge1xuXHRcdCAgICAgIGlmICghKCdkZWZhdWx0JyBpbiBtb2R1bGVPYmplY3QpKSB7XG5cdFx0ICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wJyArICdvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG5cdFx0ICAgICAgICAnY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcCcgKyBcIm9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXG5cdFx0ICAgIHJldHVybiBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblx0XHQgIH0gZWxzZSB7XG5cdFx0ICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcblx0XHQgIH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBsYXp5KGN0b3IpIHtcblx0XHQgIHZhciBwYXlsb2FkID0ge1xuXHRcdCAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG5cdFx0ICAgIF9zdGF0dXM6IFVuaW5pdGlhbGl6ZWQsXG5cdFx0ICAgIF9yZXN1bHQ6IGN0b3Jcblx0XHQgIH07XG5cdFx0ICB2YXIgbGF6eVR5cGUgPSB7XG5cdFx0ICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG5cdFx0ICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuXHRcdCAgICBfaW5pdDogbGF6eUluaXRpYWxpemVyXG5cdFx0ICB9O1xuXG5cdFx0ICB7XG5cdFx0ICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cblx0XHQgICAgdmFyIGRlZmF1bHRQcm9wcztcblx0XHQgICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG5cdFx0ICAgICAgZGVmYXVsdFByb3BzOiB7XG5cdFx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdFx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcblx0XHQgICAgICAgIH0sXG5cdFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcblx0XHQgICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuXHRcdCAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuXHRcdCAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG5cblx0XHQgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuXHRcdCAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcblx0XHQgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfSxcblx0XHQgICAgICBwcm9wVHlwZXM6IHtcblx0XHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgICByZXR1cm4gcHJvcFR5cGVzO1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuXHRcdCAgICAgICAgICBlcnJvcignUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuXG5cdFx0ICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG5cdFx0ICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuXHRcdCAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG5cdFx0ICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuXHRcdCAgICAgICAgICB9KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gbGF6eVR5cGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcblx0XHQgIHtcblx0XHQgICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG5cdFx0ICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuXHRcdCAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcblx0XHQgICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcblx0XHQgICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cblx0XHQgICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG5cdFx0ICAgICAgaWYgKHJlbmRlci5kZWZhdWx0UHJvcHMgIT0gbnVsbCB8fCByZW5kZXIucHJvcFR5cGVzICE9IG51bGwpIHtcblx0XHQgICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgfVxuXG5cdFx0ICB2YXIgZWxlbWVudFR5cGUgPSB7XG5cdFx0ICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuXHRcdCAgICByZW5kZXI6IHJlbmRlclxuXHRcdCAgfTtcblxuXHRcdCAge1xuXHRcdCAgICB2YXIgb3duTmFtZTtcblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG5cdFx0ICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0ICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdCAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIG93bk5hbWU7XG5cdFx0ICAgICAgfSxcblx0XHQgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0ICAgICAgICBvd25OYW1lID0gbmFtZTsgLy8gVGhlIGlubmVyIGNvbXBvbmVudCBzaG91bGRuJ3QgaW5oZXJpdCB0aGlzIGRpc3BsYXkgbmFtZSBpbiBtb3N0IGNhc2VzLFxuXHRcdCAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cblx0XHQgICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcblx0XHQgICAgICAgIC8vIHNvIHRoYXQgb3VyIGNvbXBvbmVudC1zdGFjayBnZW5lcmF0aW9uIGxvZ2ljIHdpbGwgZGlzcGxheSB0aGVpciBmcmFtZXMuXG5cdFx0ICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuXHRcdCAgICAgICAgLy8gICBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7Li4ufSk7XG5cdFx0ICAgICAgICAvLyBUaGlzIGtpbmQgb2YgaW5uZXIgZnVuY3Rpb24gaXMgbm90IHVzZWQgZWxzZXdoZXJlIHNvIHRoZSBzaWRlIGVmZmVjdCBpcyBva2F5LlxuXG5cdFx0ICAgICAgICBpZiAoIXJlbmRlci5uYW1lICYmICFyZW5kZXIuZGlzcGxheU5hbWUpIHtcblx0XHQgICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9XG5cdFx0ICAgIH0pO1xuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gZWxlbWVudFR5cGU7XG5cdFx0fVxuXG5cdFx0dmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cblx0XHR7XG5cdFx0ICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG5cdFx0ICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgIHJldHVybiB0cnVlO1xuXHRcdCAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cblx0XHQgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG5cdFx0ICAgIHJldHVybiB0cnVlO1xuXHRcdCAgfVxuXG5cdFx0ICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcblx0XHQgICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG5cdFx0ICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2Vcblx0XHQgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG5cdFx0ICAgIC8vIHdpdGguXG5cdFx0ICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgcmV0dXJuIHRydWU7XG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuXHRcdCAge1xuXHRcdCAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuXHRcdCAgICAgIGVycm9yKCdtZW1vOiBUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIGNvbXBvbmVudC4gSW5zdGVhZCAnICsgJ3JlY2VpdmVkOiAlcycsIHR5cGUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdHlwZSk7XG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgdmFyIGVsZW1lbnRUeXBlID0ge1xuXHRcdCAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuXHRcdCAgICB0eXBlOiB0eXBlLFxuXHRcdCAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuXHRcdCAgfTtcblxuXHRcdCAge1xuXHRcdCAgICB2YXIgb3duTmFtZTtcblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG5cdFx0ICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0ICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdCAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgcmV0dXJuIG93bk5hbWU7XG5cdFx0ICAgICAgfSxcblx0XHQgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0ICAgICAgICBvd25OYW1lID0gbmFtZTsgLy8gVGhlIGlubmVyIGNvbXBvbmVudCBzaG91bGRuJ3QgaW5oZXJpdCB0aGlzIGRpc3BsYXkgbmFtZSBpbiBtb3N0IGNhc2VzLFxuXHRcdCAgICAgICAgLy8gYmVjYXVzZSB0aGUgY29tcG9uZW50IG1heSBiZSB1c2VkIGVsc2V3aGVyZS5cblx0XHQgICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcblx0XHQgICAgICAgIC8vIHNvIHRoYXQgb3VyIGNvbXBvbmVudC1zdGFjayBnZW5lcmF0aW9uIGxvZ2ljIHdpbGwgZGlzcGxheSB0aGVpciBmcmFtZXMuXG5cdFx0ICAgICAgICAvLyBBbiBhbm9ueW1vdXMgZnVuY3Rpb24gZ2VuZXJhbGx5IHN1Z2dlc3RzIGEgcGF0dGVybiBsaWtlOlxuXHRcdCAgICAgICAgLy8gICBSZWFjdC5tZW1vKChwcm9wcykgPT4gey4uLn0pO1xuXHRcdCAgICAgICAgLy8gVGhpcyBraW5kIG9mIGlubmVyIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIGVsc2V3aGVyZSBzbyB0aGUgc2lkZSBlZmZlY3QgaXMgb2theS5cblxuXHRcdCAgICAgICAgaWYgKCF0eXBlLm5hbWUgJiYgIXR5cGUuZGlzcGxheU5hbWUpIHtcblx0XHQgICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9KTtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIGVsZW1lbnRUeXBlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuXHRcdCAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cblx0XHQgIHtcblx0XHQgICAgaWYgKGRpc3BhdGNoZXIgPT09IG51bGwpIHtcblx0XHQgICAgICBlcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xuXHRcdCAgICB9XG5cdFx0ICB9IC8vIFdpbGwgcmVzdWx0IGluIGEgbnVsbCBhY2Nlc3MgZXJyb3IgaWYgYWNjZXNzZWQgb3V0c2lkZSByZW5kZXIgcGhhc2UuIFdlXG5cdFx0ICAvLyBpbnRlbnRpb25hbGx5IGRvbid0IHRocm93IG91ciBvd24gZXJyb3IgYmVjYXVzZSB0aGlzIGlzIGluIGEgaG90IHBhdGguXG5cdFx0ICAvLyBBbHNvIGhlbHBzIGVuc3VyZSB0aGlzIGlzIGlubGluZWQuXG5cblxuXHRcdCAgcmV0dXJuIGRpc3BhdGNoZXI7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCkge1xuXHRcdCAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG5cdFx0ICB7XG5cdFx0ICAgIC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cblx0XHQgICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3Ncblx0XHQgICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cblx0XHQgICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcblx0XHQgICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG5cdFx0ICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuXHRcdCAgICAgICAgZXJyb3IoJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG5cdFx0ICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cdFx0ICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcblx0XHQgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblx0XHQgIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcblx0XHQgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblx0XHQgIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG5cdFx0ICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cdFx0ICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gdXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuXHRcdCAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXHRcdCAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcblx0XHQgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblx0XHQgIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuXHRcdCAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXHRcdCAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuXHRcdCAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXHRcdCAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG5cdFx0ICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cdFx0ICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcblx0XHQgIHtcblx0XHQgICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXHRcdCAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG5cdFx0ICB9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG5cdFx0ICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cdFx0ICByZXR1cm4gZGlzcGF0Y2hlci51c2VUcmFuc2l0aW9uKCk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUpIHtcblx0XHQgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblx0XHQgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlZmVycmVkVmFsdWUodmFsdWUpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiB1c2VJZCgpIHtcblx0XHQgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblx0XHQgIHJldHVybiBkaXNwYXRjaGVyLnVzZUlkKCk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG5cdFx0ICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cdFx0ICByZXR1cm4gZGlzcGF0Y2hlci51c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG5cdFx0fVxuXG5cdFx0Ly8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuXHRcdC8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG5cdFx0Ly8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuXHRcdC8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxuXHRcdHZhciBkaXNhYmxlZERlcHRoID0gMDtcblx0XHR2YXIgcHJldkxvZztcblx0XHR2YXIgcHJldkluZm87XG5cdFx0dmFyIHByZXZXYXJuO1xuXHRcdHZhciBwcmV2RXJyb3I7XG5cdFx0dmFyIHByZXZHcm91cDtcblx0XHR2YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xuXHRcdHZhciBwcmV2R3JvdXBFbmQ7XG5cblx0XHRmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cblx0XHRkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuXHRcdGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuXHRcdCAge1xuXHRcdCAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuXHRcdCAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuXHRcdCAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcblx0XHQgICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcblx0XHQgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2Fybjtcblx0XHQgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuXHRcdCAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG5cdFx0ICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcblx0XHQgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cblx0XHQgICAgICB2YXIgcHJvcHMgPSB7XG5cdFx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdFx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuXHRcdCAgICAgICAgd3JpdGFibGU6IHRydWVcblx0XHQgICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG5cdFx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuXHRcdCAgICAgICAgaW5mbzogcHJvcHMsXG5cdFx0ICAgICAgICBsb2c6IHByb3BzLFxuXHRcdCAgICAgICAgd2FybjogcHJvcHMsXG5cdFx0ICAgICAgICBlcnJvcjogcHJvcHMsXG5cdFx0ICAgICAgICBncm91cDogcHJvcHMsXG5cdFx0ICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG5cdFx0ICAgICAgICBncm91cEVuZDogcHJvcHNcblx0XHQgICAgICB9KTtcblx0XHQgICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuXHRcdCAgICB9XG5cblx0XHQgICAgZGlzYWJsZWREZXB0aCsrO1xuXHRcdCAgfVxuXHRcdH1cblx0XHRmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG5cdFx0ICB7XG5cdFx0ICAgIGRpc2FibGVkRGVwdGgtLTtcblxuXHRcdCAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuXHRcdCAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuXHRcdCAgICAgIHZhciBwcm9wcyA9IHtcblx0XHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgICAgICB3cml0YWJsZTogdHJ1ZVxuXHRcdCAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cblx0XHQgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG5cdFx0ICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcblx0XHQgICAgICAgICAgdmFsdWU6IHByZXZMb2dcblx0XHQgICAgICAgIH0pLFxuXHRcdCAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuXHRcdCAgICAgICAgICB2YWx1ZTogcHJldkluZm9cblx0XHQgICAgICAgIH0pLFxuXHRcdCAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuXHRcdCAgICAgICAgICB2YWx1ZTogcHJldldhcm5cblx0XHQgICAgICAgIH0pLFxuXHRcdCAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcblx0XHQgICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuXHRcdCAgICAgICAgfSksXG5cdFx0ICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuXHRcdCAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG5cdFx0ICAgICAgICB9KSxcblx0XHQgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG5cdFx0ICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcblx0XHQgICAgICAgIH0pLFxuXHRcdCAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcblx0XHQgICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuXHRcdCAgICAgICAgfSlcblx0XHQgICAgICB9KTtcblx0XHQgICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuXHRcdCAgICB9XG5cblx0XHQgICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG5cdFx0ICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0dmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG5cdFx0dmFyIHByZWZpeDtcblx0XHRmdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcblx0XHQgIHtcblx0XHQgICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuXHRcdCAgICAgIHRyeSB7XG5cdFx0ICAgICAgICB0aHJvdyBFcnJvcigpO1xuXHRcdCAgICAgIH0gY2F0Y2ggKHgpIHtcblx0XHQgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG5cdFx0ICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcblx0XHQgICAgICB9XG5cdFx0ICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuXHRcdCAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuXHRcdCAgfVxuXHRcdH1cblx0XHR2YXIgcmVlbnRyeSA9IGZhbHNlO1xuXHRcdHZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG5cdFx0e1xuXHRcdCAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblx0XHQgIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG5cdFx0ICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cblx0XHQgIGlmICggIWZuIHx8IHJlZW50cnkpIHtcblx0XHQgICAgcmV0dXJuICcnO1xuXHRcdCAgfVxuXG5cdFx0ICB7XG5cdFx0ICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuXHRcdCAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgIHJldHVybiBmcmFtZTtcblx0XHQgICAgfVxuXHRcdCAgfVxuXG5cdFx0ICB2YXIgY29udHJvbDtcblx0XHQgIHJlZW50cnkgPSB0cnVlO1xuXHRcdCAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cblx0XHQgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuXHRcdCAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuXHRcdCAge1xuXHRcdCAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG5cdFx0ICAgIC8vIGZvciB3YXJuaW5ncy5cblxuXHRcdCAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG5cdFx0ICAgIGRpc2FibGVMb2dzKCk7XG5cdFx0ICB9XG5cblx0XHQgIHRyeSB7XG5cdFx0ICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuXHRcdCAgICBpZiAoY29uc3RydWN0KSB7XG5cdFx0ICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG5cdFx0ICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB0aHJvdyBFcnJvcigpO1xuXHRcdCAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG5cdFx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG5cdFx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuXHRcdCAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG5cdFx0ICAgICAgICAgIHRocm93IEVycm9yKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfSk7XG5cblx0XHQgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG5cdFx0ICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG5cdFx0ICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuXHRcdCAgICAgICAgfSBjYXRjaCAoeCkge1xuXHRcdCAgICAgICAgICBjb250cm9sID0geDtcblx0XHQgICAgICAgIH1cblxuXHRcdCAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcblx0XHQgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgRmFrZS5jYWxsKCk7XG5cdFx0ICAgICAgICB9IGNhdGNoICh4KSB7XG5cdFx0ICAgICAgICAgIGNvbnRyb2wgPSB4O1xuXHRcdCAgICAgICAgfVxuXG5cdFx0ICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgdHJ5IHtcblx0XHQgICAgICAgIHRocm93IEVycm9yKCk7XG5cdFx0ICAgICAgfSBjYXRjaCAoeCkge1xuXHRcdCAgICAgICAgY29udHJvbCA9IHg7XG5cdFx0ICAgICAgfVxuXG5cdFx0ICAgICAgZm4oKTtcblx0XHQgICAgfVxuXHRcdCAgfSBjYXRjaCAoc2FtcGxlKSB7XG5cdFx0ICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG5cdFx0ICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuXHRcdCAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG5cdFx0ICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG5cdFx0ICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcblx0XHQgICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG5cdFx0ICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuXHRcdCAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cblx0XHQgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG5cdFx0ICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cblx0XHQgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcblx0XHQgICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG5cdFx0ICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuXHRcdCAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cblx0XHQgICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuXHRcdCAgICAgICAgYy0tO1xuXHRcdCAgICAgIH1cblxuXHRcdCAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuXHRcdCAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG5cdFx0ICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cblx0XHQgICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG5cdFx0ICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG5cdFx0ICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcblx0XHQgICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcblx0XHQgICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuXHRcdCAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuXHRcdCAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG5cdFx0ICAgICAgICAgICAgZG8ge1xuXHRcdCAgICAgICAgICAgICAgcy0tO1xuXHRcdCAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG5cdFx0ICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuXHRcdCAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcblx0XHQgICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG5cdFx0ICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuXHRcdCAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG5cdFx0ICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cblx0XHQgICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuXHRcdCAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXG5cdFx0ICAgICAgICAgICAgICAgIHtcblx0XHQgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcblx0XHQgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cblx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcblx0XHQgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcblx0XHQgICAgICAgICAgfVxuXG5cdFx0ICAgICAgICAgIGJyZWFrO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgfSBmaW5hbGx5IHtcblx0XHQgICAgcmVlbnRyeSA9IGZhbHNlO1xuXG5cdFx0ICAgIHtcblx0XHQgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcblx0XHQgICAgICByZWVuYWJsZUxvZ3MoKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcblx0XHQgIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cblx0XHQgIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG5cdFx0ICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuXHRcdCAge1xuXHRcdCAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcblx0XHQgICAgfVxuXHRcdCAgfVxuXG5cdFx0ICByZXR1cm4gc3ludGhldGljRnJhbWU7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG5cdFx0ICB7XG5cdFx0ICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuXHRcdCAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG5cdFx0ICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cblx0XHQgIGlmICh0eXBlID09IG51bGwpIHtcblx0XHQgICAgcmV0dXJuICcnO1xuXHRcdCAgfVxuXG5cdFx0ICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHQgICAge1xuXHRcdCAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdCAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG5cdFx0ICB9XG5cblx0XHQgIHN3aXRjaCAodHlwZSkge1xuXHRcdCAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG5cdFx0ICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG5cdFx0ICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuXHRcdCAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG5cdFx0ICB9XG5cblx0XHQgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHQgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG5cdFx0ICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuXHRcdCAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cblx0XHQgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcblx0XHQgICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG5cdFx0ICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuXHRcdCAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuXHRcdCAgICAgICAge1xuXHRcdCAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG5cdFx0ICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcblx0XHQgICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG5cdFx0ICAgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cblx0XHQgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG5cdFx0ICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblx0XHR2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuXHRcdGZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcblx0XHQgIHtcblx0XHQgICAgaWYgKGVsZW1lbnQpIHtcblx0XHQgICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblx0XHQgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuXHRcdCAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcblx0XHQgIHtcblx0XHQgICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuXHRcdCAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuXHRcdCAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG5cdFx0ICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcblx0XHQgICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuXHRcdCAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuXHRcdCAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG5cdFx0ICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcblx0XHQgICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuXHRcdCAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblx0XHQgICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcblx0XHQgICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcblx0XHQgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdFx0ICAgICAgICAgIH1cblxuXHRcdCAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcblx0XHQgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG5cdFx0ICAgICAgICAgIGVycm9yJDEgPSBleDtcblx0XHQgICAgICAgIH1cblxuXHRcdCAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG5cdFx0ICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG5cdFx0ICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG5cdFx0ICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuXHRcdCAgICAgICAgfVxuXG5cdFx0ICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcblx0XHQgICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG5cdFx0ICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG5cdFx0ICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcblx0XHQgICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cblx0XHQgICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG5cdFx0ICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRcdCAgfVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuXHRcdCAge1xuXHRcdCAgICBpZiAoZWxlbWVudCkge1xuXHRcdCAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXHRcdCAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG5cdFx0ICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHR2YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cblx0XHR7XG5cdFx0ICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcblx0XHQgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG5cdFx0ICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cblx0XHQgICAgaWYgKG5hbWUpIHtcblx0XHQgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuXHRcdCAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0ICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG5cdFx0ICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG5cdFx0ICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiAnJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuXHRcdCAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuICcnO1xuXHRcdH1cblx0XHQvKipcblx0XHQgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG5cdFx0ICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG5cdFx0ICogdXBkYXRlcy5cblx0XHQgKi9cblxuXG5cdFx0dmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG5cdFx0ICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG5cdFx0ICBpZiAoIWluZm8pIHtcblx0XHQgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cblx0XHQgICAgaWYgKHBhcmVudE5hbWUpIHtcblx0XHQgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG5cdFx0ICAgIH1cblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIGluZm87XG5cdFx0fVxuXHRcdC8qKlxuXHRcdCAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cblx0XHQgKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcblx0XHQgKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cblx0XHQgKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcblx0XHQgKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cblx0XHQgKlxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cblx0XHQgKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG5cdFx0ICovXG5cblxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuXHRcdCAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuXHRcdCAgICByZXR1cm47XG5cdFx0ICB9XG5cblx0XHQgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cdFx0ICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cblx0XHQgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcblx0XHQgICAgcmV0dXJuO1xuXHRcdCAgfVxuXG5cdFx0ICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuXHRcdCAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuXHRcdCAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG5cdFx0ICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG5cdFx0ICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuXHRcdCAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cblx0XHQgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG5cdFx0ICB9XG5cblx0XHQgIHtcblx0XHQgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuXHRcdCAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuXHRcdCAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuXHRcdCAgfVxuXHRcdH1cblx0XHQvKipcblx0XHQgKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG5cdFx0ICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG5cdFx0ICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG5cdFx0ICpcblx0XHQgKiBAaW50ZXJuYWxcblx0XHQgKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cblx0XHQgKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG5cdFx0ICovXG5cblxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcblx0XHQgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcblx0XHQgICAgcmV0dXJuO1xuXHRcdCAgfVxuXG5cdFx0ICBpZiAoaXNBcnJheShub2RlKSkge1xuXHRcdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcblx0XHQgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG5cdFx0ICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuXHRcdCAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cdFx0ICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG5cdFx0ICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG5cdFx0ICAgIGlmIChub2RlLl9zdG9yZSkge1xuXHRcdCAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cdFx0ICAgIH1cblx0XHQgIH0gZWxzZSBpZiAobm9kZSkge1xuXHRcdCAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cblx0XHQgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuXHRcdCAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuXHRcdCAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcblx0XHQgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcblx0XHQgICAgICAgIHZhciBzdGVwO1xuXG5cdFx0ICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG5cdFx0ICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuXHRcdCAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG5cdFx0ICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cdFx0LyoqXG5cdFx0ICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcblx0XHQgKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG5cdFx0ICovXG5cblxuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcblx0XHQgIHtcblx0XHQgICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cblx0XHQgICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdCAgICAgIHJldHVybjtcblx0XHQgICAgfVxuXG5cdFx0ICAgIHZhciBwcm9wVHlwZXM7XG5cblx0XHQgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0ICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG5cdFx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cblx0XHQgICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG5cdFx0ICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcblx0XHQgICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICByZXR1cm47XG5cdFx0ICAgIH1cblxuXHRcdCAgICBpZiAocHJvcFR5cGVzKSB7XG5cdFx0ICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblx0XHQgICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblx0XHQgICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG5cdFx0ICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcblx0XHQgICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cblx0XHQgICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cblx0XHQgICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG5cdFx0ICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcblx0XHQgICAgfVxuXHRcdCAgfVxuXHRcdH1cblx0XHQvKipcblx0XHQgKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcblx0XHQgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcblx0XHQgKi9cblxuXG5cdFx0ZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG5cdFx0ICB7XG5cdFx0ICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG5cdFx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdCAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG5cdFx0ICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG5cdFx0ICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuXHRcdCAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG5cdFx0ICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuXHRcdCAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9XG5cblx0XHQgICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuXHRcdCAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG5cdFx0ICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cblx0XHQgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0XHQgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG5cdFx0ICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG5cdFx0ICBpZiAoIXZhbGlkVHlwZSkge1xuXHRcdCAgICB2YXIgaW5mbyA9ICcnO1xuXG5cdFx0ICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcblx0XHQgICAgfVxuXG5cdFx0ICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cblx0XHQgICAgaWYgKHNvdXJjZUluZm8pIHtcblx0XHQgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIHZhciB0eXBlU3RyaW5nO1xuXG5cdFx0ICAgIGlmICh0eXBlID09PSBudWxsKSB7XG5cdFx0ICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcblx0XHQgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG5cdFx0ICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG5cdFx0ICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuXHRcdCAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcblx0XHQgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuXHRcdCAgICB9XG5cblx0XHQgICAge1xuXHRcdCAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cblx0XHQgIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuXHRcdCAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG5cdFx0ICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG5cdFx0ICAgIHJldHVybiBlbGVtZW50O1xuXHRcdCAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuXHRcdCAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuXHRcdCAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuXHRcdCAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcblx0XHQgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG5cdFx0ICBpZiAodmFsaWRUeXBlKSB7XG5cdFx0ICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcblx0XHQgICAgfVxuXHRcdCAgfVxuXG5cdFx0ICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuXHRcdCAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdCAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIGVsZW1lbnQ7XG5cdFx0fVxuXHRcdHZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuXHRcdGZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG5cdFx0ICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuXHRcdCAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuXHRcdCAge1xuXHRcdCAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5KSB7XG5cdFx0ICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG5cdFx0ICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcblx0XHQgICAgfSAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cblxuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG5cdFx0ICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0ICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cblx0XHQgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcblx0XHQgICAgICAgICAgdmFsdWU6IHR5cGVcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgcmV0dXJuIHR5cGU7XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9KTtcblx0XHQgIH1cblxuXHRcdCAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuXHRcdCAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdCAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHQgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuXHRcdCAgfVxuXG5cdFx0ICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcblx0XHQgIHJldHVybiBuZXdFbGVtZW50O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzY29wZSwgb3B0aW9ucykge1xuXHRcdCAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcblx0XHQgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSB7fTtcblx0XHQgIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG5cblx0XHQgIHtcblx0XHQgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcblx0XHQgIH1cblxuXHRcdCAgdHJ5IHtcblx0XHQgICAgc2NvcGUoKTtcblx0XHQgIH0gZmluYWxseSB7XG5cdFx0ICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcblxuXHRcdCAgICB7XG5cdFx0ICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG5cdFx0ICAgICAgICB2YXIgdXBkYXRlZEZpYmVyc0NvdW50ID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZTtcblxuXHRcdCAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG5cdFx0ICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcblx0XHQgICAgICAgIH1cblxuXHRcdCAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHR2YXIgZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwgPSBmYWxzZTtcblx0XHR2YXIgZW5xdWV1ZVRhc2tJbXBsID0gbnVsbDtcblx0XHRmdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG5cdFx0ICBpZiAoZW5xdWV1ZVRhc2tJbXBsID09PSBudWxsKSB7XG5cdFx0ICAgIHRyeSB7XG5cdFx0ICAgICAgLy8gcmVhZCByZXF1aXJlIG9mZiB0aGUgbW9kdWxlIG9iamVjdCB0byBnZXQgYXJvdW5kIHRoZSBidW5kbGVycy5cblx0XHQgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZW0gdG8gZGV0ZWN0IGEgcmVxdWlyZSBhbmQgYnVuZGxlIGEgTm9kZSBwb2x5ZmlsbC5cblx0XHQgICAgICB2YXIgcmVxdWlyZVN0cmluZyA9ICgncmVxdWlyZScgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgwLCA3KTtcblx0XHQgICAgICB2YXIgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddOyAvLyBhc3N1bWluZyB3ZSdyZSBpbiBub2RlLCBsZXQncyB0cnkgdG8gZ2V0IG5vZGUnc1xuXHRcdCAgICAgIC8vIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLCBieXBhc3NpbmcgZmFrZSB0aW1lcnMgaWYgYW55LlxuXG5cdFx0ICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gbm9kZVJlcXVpcmUuY2FsbChtb2R1bGUsICd0aW1lcnMnKS5zZXRJbW1lZGlhdGU7XG5cdFx0ICAgIH0gY2F0Y2ggKF9lcnIpIHtcblx0XHQgICAgICAvLyB3ZSdyZSBpbiBhIGJyb3dzZXJcblx0XHQgICAgICAvLyB3ZSBjYW4ndCB1c2UgcmVndWxhciB0aW1lcnMgYmVjYXVzZSB0aGV5IG1heSBzdGlsbCBiZSBmYWtlZFxuXHRcdCAgICAgIC8vIHNvIHdlIHRyeSBNZXNzYWdlQ2hhbm5lbCtwb3N0TWVzc2FnZSBpbnN0ZWFkXG5cdFx0ICAgICAgZW5xdWV1ZVRhc2tJbXBsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0ICAgICAgICB7XG5cdFx0ICAgICAgICAgIGlmIChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9PT0gZmFsc2UpIHtcblx0XHQgICAgICAgICAgICBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9IHRydWU7XG5cblx0XHQgICAgICAgICAgICBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAndW5kZWZpbmVkJykge1xuXHRcdCAgICAgICAgICAgICAgZXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgTWVzc2FnZUNoYW5uZWwgaW1wbGVtZW50YXRpb24sICcgKyAnc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3VlcyAnICsgJ2lmIHlvdSBlbmNvdW50ZXIgdGhpcyB3YXJuaW5nLicpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXG5cdFx0ICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuXHRcdCAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcblx0XHQgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcblx0XHQgICAgICB9O1xuXHRcdCAgICB9XG5cdFx0ICB9XG5cblx0XHQgIHJldHVybiBlbnF1ZXVlVGFza0ltcGwodGFzayk7XG5cdFx0fVxuXG5cdFx0dmFyIGFjdFNjb3BlRGVwdGggPSAwO1xuXHRcdHZhciBkaWRXYXJuTm9Bd2FpdEFjdCA9IGZhbHNlO1xuXHRcdGZ1bmN0aW9uIGFjdChjYWxsYmFjaykge1xuXHRcdCAge1xuXHRcdCAgICAvLyBgYWN0YCBjYWxscyBjYW4gYmUgbmVzdGVkLCBzbyB3ZSB0cmFjayB0aGUgZGVwdGguIFRoaXMgcmVwcmVzZW50cyB0aGVcblx0XHQgICAgLy8gbnVtYmVyIG9mIGBhY3RgIHNjb3BlcyBvbiB0aGUgc3RhY2suXG5cdFx0ICAgIHZhciBwcmV2QWN0U2NvcGVEZXB0aCA9IGFjdFNjb3BlRGVwdGg7XG5cdFx0ICAgIGFjdFNjb3BlRGVwdGgrKztcblxuXHRcdCAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9PT0gbnVsbCkge1xuXHRcdCAgICAgIC8vIFRoaXMgaXMgdGhlIG91dGVybW9zdCBgYWN0YCBzY29wZS4gSW5pdGlhbGl6ZSB0aGUgcXVldWUuIFRoZSByZWNvbmNpbGVyXG5cdFx0ICAgICAgLy8gd2lsbCBkZXRlY3QgdGhlIHF1ZXVlIGFuZCB1c2UgaXQgaW5zdGVhZCBvZiBTY2hlZHVsZXIuXG5cdFx0ICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IFtdO1xuXHRcdCAgICB9XG5cblx0XHQgICAgdmFyIHByZXZJc0JhdGNoaW5nTGVnYWN5ID0gUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeTtcblx0XHQgICAgdmFyIHJlc3VsdDtcblxuXHRcdCAgICB0cnkge1xuXHRcdCAgICAgIC8vIFVzZWQgdG8gcmVwcm9kdWNlIGJlaGF2aW9yIG9mIGBiYXRjaGVkVXBkYXRlc2AgaW4gbGVnYWN5IG1vZGUuIE9ubHlcblx0XHQgICAgICAvLyBzZXQgdG8gYHRydWVgIHdoaWxlIHRoZSBnaXZlbiBjYWxsYmFjayBpcyBleGVjdXRlZCwgbm90IGZvciB1cGRhdGVzXG5cdFx0ICAgICAgLy8gdHJpZ2dlcmVkIGR1cmluZyBhbiBhc3luYyBldmVudCwgYmVjYXVzZSB0aGlzIGlzIGhvdyB0aGUgbGVnYWN5XG5cdFx0ICAgICAgLy8gaW1wbGVtZW50YXRpb24gb2YgYGFjdGAgYmVoYXZlZC5cblx0XHQgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gdHJ1ZTtcblx0XHQgICAgICByZXN1bHQgPSBjYWxsYmFjaygpOyAvLyBSZXBsaWNhdGUgYmVoYXZpb3Igb2Ygb3JpZ2luYWwgYGFjdGAgaW1wbGVtZW50YXRpb24gaW4gbGVnYWN5IG1vZGUsXG5cdFx0ICAgICAgLy8gd2hpY2ggZmx1c2hlZCB1cGRhdGVzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBzY29wZSBmdW5jdGlvbiBleGl0cywgZXZlblxuXHRcdCAgICAgIC8vIGlmIGl0J3MgYW4gYXN5bmMgZnVuY3Rpb24uXG5cblx0XHQgICAgICBpZiAoIXByZXZJc0JhdGNoaW5nTGVnYWN5ICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlKSB7XG5cdFx0ICAgICAgICB2YXIgcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuXG5cdFx0ICAgICAgICBpZiAocXVldWUgIT09IG51bGwpIHtcblx0XHQgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBmYWxzZTtcblx0XHQgICAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfVxuXHRcdCAgICB9IGNhdGNoIChlcnJvcikge1xuXHRcdCAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcblx0XHQgICAgICB0aHJvdyBlcnJvcjtcblx0XHQgICAgfSBmaW5hbGx5IHtcblx0XHQgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5ID0gcHJldklzQmF0Y2hpbmdMZWdhY3k7XG5cdFx0ICAgIH1cblxuXHRcdCAgICBpZiAocmVzdWx0ICE9PSBudWxsICYmIHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdCAgICAgIHZhciB0aGVuYWJsZVJlc3VsdCA9IHJlc3VsdDsgLy8gVGhlIGNhbGxiYWNrIGlzIGFuIGFzeW5jIGZ1bmN0aW9uIChpLmUuIHJldHVybmVkIGEgcHJvbWlzZSkuIFdhaXRcblx0XHQgICAgICAvLyBmb3IgaXQgdG8gcmVzb2x2ZSBiZWZvcmUgZXhpdGluZyB0aGUgY3VycmVudCBzY29wZS5cblxuXHRcdCAgICAgIHZhciB3YXNBd2FpdGVkID0gZmFsc2U7XG5cdFx0ICAgICAgdmFyIHRoZW5hYmxlID0ge1xuXHRcdCAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdCAgICAgICAgICB3YXNBd2FpdGVkID0gdHJ1ZTtcblx0XHQgICAgICAgICAgdGhlbmFibGVSZXN1bHQudGhlbihmdW5jdGlvbiAocmV0dXJuVmFsdWUpIHtcblx0XHQgICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG5cblx0XHQgICAgICAgICAgICBpZiAoYWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgICAgLy8gV2UndmUgZXhpdGVkIHRoZSBvdXRlcm1vc3QgYWN0IHNjb3BlLiBSZWN1cnNpdmVseSBmbHVzaCB0aGVcblx0XHQgICAgICAgICAgICAgIC8vIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG5cdFx0ICAgICAgICAgICAgICByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuXHRcdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdCAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayB0aHJldyBhbiBlcnJvci5cblx0XHQgICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG5cdFx0ICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0XHQgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfTtcblxuXHRcdCAgICAgIHtcblx0XHQgICAgICAgIGlmICghZGlkV2Fybk5vQXdhaXRBY3QgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0ICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHRcdCAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHt9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIXdhc0F3YWl0ZWQpIHtcblx0XHQgICAgICAgICAgICAgIGRpZFdhcm5Ob0F3YWl0QWN0ID0gdHJ1ZTtcblxuXHRcdCAgICAgICAgICAgICAgZXJyb3IoJ1lvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gJyArICdUaGlzIGNvdWxkIGxlYWQgdG8gdW5leHBlY3RlZCB0ZXN0aW5nIGJlaGF2aW91ciwgJyArICdpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgJyArICdzY29wZXMuICcgKyAnWW91IHNob3VsZCAtIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pOycpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfVxuXG5cdFx0ICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuXHRcdCAgICB9IGVsc2Uge1xuXHRcdCAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHJlc3VsdDsgLy8gVGhlIGNhbGxiYWNrIGlzIG5vdCBhbiBhc3luYyBmdW5jdGlvbi4gRXhpdCB0aGUgY3VycmVudCBzY29wZVxuXHRcdCAgICAgIC8vIGltbWVkaWF0ZWx5LCB3aXRob3V0IGF3YWl0aW5nLlxuXG5cdFx0ICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuXG5cdFx0ICAgICAgaWYgKGFjdFNjb3BlRGVwdGggPT09IDApIHtcblx0XHQgICAgICAgIC8vIEV4aXRpbmcgdGhlIG91dGVybW9zdCBhY3Qgc2NvcGUuIEZsdXNoIHRoZSBxdWV1ZS5cblx0XHQgICAgICAgIHZhciBfcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuXG5cdFx0ICAgICAgICBpZiAoX3F1ZXVlICE9PSBudWxsKSB7XG5cdFx0ICAgICAgICAgIGZsdXNoQWN0UXVldWUoX3F1ZXVlKTtcblx0XHQgICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG5cdFx0ICAgICAgICB9IC8vIFJldHVybiBhIHRoZW5hYmxlLiBJZiB0aGUgdXNlciBhd2FpdHMgaXQsIHdlJ2xsIGZsdXNoIGFnYWluIGluXG5cdFx0ICAgICAgICAvLyBjYXNlIGFkZGl0aW9uYWwgd29yayB3YXMgc2NoZWR1bGVkIGJ5IGEgbWljcm90YXNrLlxuXG5cblx0XHQgICAgICAgIHZhciBfdGhlbmFibGUgPSB7XG5cdFx0ICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHQgICAgICAgICAgICAvLyBDb25maXJtIHdlIGhhdmVuJ3QgcmUtZW50ZXJlZCBhbm90aGVyIGBhY3RgIHNjb3BlLCBpbiBjYXNlXG5cdFx0ICAgICAgICAgICAgLy8gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgd2VpcmQgbGlrZSBhd2FpdCB0aGUgdGhlbmFibGVcblx0XHQgICAgICAgICAgICAvLyBtdWx0aXBsZSB0aW1lcy5cblx0XHQgICAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9PT0gbnVsbCkge1xuXHRcdCAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmx1c2ggdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG5cdFx0ICAgICAgICAgICAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50ID0gW107XG5cdFx0ICAgICAgICAgICAgICByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuXHRcdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgIH1cblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICByZXR1cm4gX3RoZW5hYmxlO1xuXHRcdCAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICAvLyBTaW5jZSB3ZSdyZSBpbnNpZGUgYSBuZXN0ZWQgYGFjdGAgc2NvcGUsIHRoZSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdCAgICAgICAgLy8gaW1tZWRpYXRlbHkgcmVzb2x2ZXMuIFRoZSBvdXRlciBzY29wZSB3aWxsIGZsdXNoIHRoZSBxdWV1ZS5cblx0XHQgICAgICAgIHZhciBfdGhlbmFibGUyID0ge1xuXHRcdCAgICAgICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0ICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG5cdFx0ICAgICAgICAgIH1cblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICByZXR1cm4gX3RoZW5hYmxlMjtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCkge1xuXHRcdCAge1xuXHRcdCAgICBpZiAocHJldkFjdFNjb3BlRGVwdGggIT09IGFjdFNjb3BlRGVwdGggLSAxKSB7XG5cdFx0ICAgICAgZXJyb3IoJ1lvdSBzZWVtIHRvIGhhdmUgb3ZlcmxhcHBpbmcgYWN0KCkgY2FsbHMsIHRoaXMgaXMgbm90IHN1cHBvcnRlZC4gJyArICdCZSBzdXJlIHRvIGF3YWl0IHByZXZpb3VzIGFjdCgpIGNhbGxzIGJlZm9yZSBtYWtpbmcgYSBuZXcgb25lLiAnKTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcblx0XHQgIH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpIHtcblx0XHQgIHtcblx0XHQgICAgdmFyIHF1ZXVlID0gUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudDtcblxuXHRcdCAgICBpZiAocXVldWUgIT09IG51bGwpIHtcblx0XHQgICAgICB0cnkge1xuXHRcdCAgICAgICAgZmx1c2hBY3RRdWV1ZShxdWV1ZSk7XG5cdFx0ICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcblx0XHQgICAgICAgICAgICAvLyBObyBhZGRpdGlvbmFsIHdvcmsgd2FzIHNjaGVkdWxlZC4gRmluaXNoLlxuXHRcdCAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuXHRcdCAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuXHRcdCAgICAgICAgICB9IGVsc2Uge1xuXHRcdCAgICAgICAgICAgIC8vIEtlZXAgZmx1c2hpbmcgd29yayB1bnRpbCB0aGVyZSdzIG5vbmUgbGVmdC5cblx0XHQgICAgICAgICAgICByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuXHRcdCAgICAgICAgICB9XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICB9IGNhdGNoIChlcnJvcikge1xuXHRcdCAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHR2YXIgaXNGbHVzaGluZyA9IGZhbHNlO1xuXG5cdFx0ZnVuY3Rpb24gZmx1c2hBY3RRdWV1ZShxdWV1ZSkge1xuXHRcdCAge1xuXHRcdCAgICBpZiAoIWlzRmx1c2hpbmcpIHtcblx0XHQgICAgICAvLyBQcmV2ZW50IHJlLWVudHJhbmNlLlxuXHRcdCAgICAgIGlzRmx1c2hpbmcgPSB0cnVlO1xuXHRcdCAgICAgIHZhciBpID0gMDtcblxuXHRcdCAgICAgIHRyeSB7XG5cdFx0ICAgICAgICBmb3IgKDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0ICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuXG5cdFx0ICAgICAgICAgIGRvIHtcblx0XHQgICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrKHRydWUpO1xuXHRcdCAgICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG5cdFx0ICAgICAgICB9XG5cblx0XHQgICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0ICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblx0XHQgICAgICAgIC8vIElmIHNvbWV0aGluZyB0aHJvd3MsIGxlYXZlIHRoZSByZW1haW5pbmcgY2FsbGJhY2tzIG9uIHRoZSBxdWV1ZS5cblx0XHQgICAgICAgIHF1ZXVlID0gcXVldWUuc2xpY2UoaSArIDEpO1xuXHRcdCAgICAgICAgdGhyb3cgZXJyb3I7XG5cdFx0ICAgICAgfSBmaW5hbGx5IHtcblx0XHQgICAgICAgIGlzRmx1c2hpbmcgPSBmYWxzZTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgIH1cblx0XHR9XG5cblx0XHR2YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG5cdFx0dmFyIGNsb25lRWxlbWVudCQxID0gIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcblx0XHR2YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xuXHRcdHZhciBDaGlsZHJlbiA9IHtcblx0XHQgIG1hcDogbWFwQ2hpbGRyZW4sXG5cdFx0ICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG5cdFx0ICBjb3VudDogY291bnRDaGlsZHJlbixcblx0XHQgIHRvQXJyYXk6IHRvQXJyYXksXG5cdFx0ICBvbmx5OiBvbmx5Q2hpbGRcblx0XHR9O1xuXG5cdFx0ZXhwb3J0cy5DaGlsZHJlbiA9IENoaWxkcmVuO1xuXHRcdGV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuXHRcdGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuXHRcdGV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuXHRcdGV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5cdFx0ZXhwb3J0cy5TdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcblx0XHRleHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcblx0XHRleHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5cdFx0ZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBjbG9uZUVsZW1lbnQkMTtcblx0XHRleHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuXHRcdGV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcblx0XHRleHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBjcmVhdGVGYWN0b3J5O1xuXHRcdGV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuXHRcdGV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5cdFx0ZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuXHRcdGV4cG9ydHMubGF6eSA9IGxhenk7XG5cdFx0ZXhwb3J0cy5tZW1vID0gbWVtbztcblx0XHRleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IHN0YXJ0VHJhbnNpdGlvbjtcblx0XHRleHBvcnRzLnVuc3RhYmxlX2FjdCA9IGFjdDtcblx0XHRleHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5cdFx0ZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcblx0XHRleHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuXHRcdGV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IHVzZURlZmVycmVkVmFsdWU7XG5cdFx0ZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5cdFx0ZXhwb3J0cy51c2VJZCA9IHVzZUlkO1xuXHRcdGV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5cdFx0ZXhwb3J0cy51c2VJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3Q7XG5cdFx0ZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5cdFx0ZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcblx0XHRleHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuXHRcdGV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuXHRcdGV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcblx0XHRleHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmU7XG5cdFx0ZXhwb3J0cy51c2VUcmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvbjtcblx0XHRleHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG5cdFx0ICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cblx0XHRpZiAoXG5cdFx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cblx0XHQgICAgJ2Z1bmN0aW9uJ1xuXHRcdCkge1xuXHRcdCAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcblx0XHR9XG5cdFx0ICAgICAgICBcblx0XHQgIH0pKCk7XG5cdFx0fSBcblx0fSAocmVhY3RfZGV2ZWxvcG1lbnQsIHJlYWN0X2RldmVsb3BtZW50LmV4cG9ydHMpKTtcblx0cmV0dXJuIHJlYWN0X2RldmVsb3BtZW50LmV4cG9ydHM7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHJlYWN0LmV4cG9ydHMgPSByZXF1aXJlUmVhY3RfcHJvZHVjdGlvbl9taW4oKTtcbn0gZWxzZSB7XG4gIHJlYWN0LmV4cG9ydHMgPSByZXF1aXJlUmVhY3RfZGV2ZWxvcG1lbnQoKTtcbn1cblxudmFyIHJlYWN0RXhwb3J0cyA9IHJlYWN0LmV4cG9ydHM7XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuXG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzc18yNDh6JDEgPSBcIi8qIFN0eWxpbmcgZm9yIHRoZSBwaWxsIGJ1dHRvbiAqL1xcblxcbi8qIEltcG9ydCB0aGUgUG9wcGlucyBmb250IGZyb20gR29vZ2xlIEZvbnRzICovXFxuQGltcG9ydCB1cmwoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9UG9wcGluczp3Z2h0QDQwMDs3MDAmZGlzcGxheT1zd2FwJyk7XFxuXFxuYnV0dG9uIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBwYWRkaW5nOiAxMHB4IDIwcHg7IC8qIEFkanVzdCBwYWRkaW5nIGFzIG5lZWRlZCAqL1xcbiAgICBib3JkZXI6IDJweCBzb2xpZCAjMDAwOyAvKiBCbGFjayBib3JkZXIgKi9cXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzAwOEFGRjsgLyogRGVlcCBibHVlIGJhY2tncm91bmQgKi9cXG5cXG4gICAgY29sb3I6ICNGRkY7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgZm9udC1mYW1pbHk6IFBvcHBpbnMsIHNhbnMtc2VyaWY7XFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBsaW5lLWhlaWdodDogbm9ybWFsO1xcblxcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MsIGNvbG9yIDIwMG1zLCBib3JkZXItY29sb3IgMC4zcztcXG4gICAgYm94LXNoYWRvdzogYmxhY2sgLTRweCA0cHggMDtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoNHB4LCAtNHB4KTtcXG59XFxuXFxuLyogSG92ZXIgZWZmZWN0ICovXFxuYnV0dG9uOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMDAwOyAvKiBCbGFjayBib3JkZXIgb24gaG92ZXIgKi9cXG4gICAgY29sb3I6ICNmZmY7IC8qIFdoaXRlIHRleHQgY29sb3Igb24gaG92ZXIgKi9cXG4gICAgYm94LXNoYWRvdzogYmxhY2sgMHB4IDBweCAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwcHgsIDBweCk7XFxufVxcblxcbmljb24ge1xcbiAgICBmb250LXNpemU6IDI0cHg7IC8qIEFkanVzdCBpY29uIHNpemUgYXMgbmVlZGVkICovXFxuICAgIG1hcmdpbi1yaWdodDogMTBweDsgLyogQWRqdXN0IHNwYWNpbmcgYmV0d2VlbiBpY29uIGFuZCB0ZXh0ICovXFxufVwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHokMSk7XG5cbmNvbnN0IENvbm5lY3RUb1RlcnJhQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgcmV0dXJuIChyZWFjdEV4cG9ydHMuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWFyb3VuZCBiZy1ibHVlLTUwMCBob3ZlcjpiZy1ibHVlLTYwMCB0ZXh0LWJvbGQgcHktMiBweC00IHJvdW5kZWQtZnVsbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCB0cmFuc2Zvcm0gaG92ZXI6c2NhbGUtMTA1IGZvbnQtc2VyaWZcIiwgb25DbGljazogcHJvcHMub25DbGljayB9LFxuICAgICAgICByZWFjdEV4cG9ydHMuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgXCJDb25uZWN0IFdlYXJhYmxlXCIpLFxuICAgICAgICByZWFjdEV4cG9ydHMuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHdpZHRoOiBcIjMwXCIsIGhlaWdodDogXCIxNVwiLCB2aWV3Qm94OiBcIjAgMCAyMCAyMFwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICAgICAgcmVhY3RFeHBvcnRzLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTggMTVMMTIgOUw2IDE1XCIsIHN0cm9rZTogXCJ3aGl0ZVwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9KSkpKTtcbn07XG5cbnZhciBjc3NfMjQ4eiA9IFwiLyogU3R5bGluZyBmb3IgdGhlIHBpbGwgYnV0dG9uICovXFxuQGltcG9ydCB1cmwoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9UG9wcGluczp3Z2h0QDQwMDs3MDAmZGlzcGxheT1zd2FwJyk7XFxuXFxuYnV0dG9uIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICBwYWRkaW5nOiAxMHB4IDIwcHg7XFxuICAgIGJvcmRlcjogMnB4IHNvbGlkICMwMDA7IC8qIEJsYWNrIGJvcmRlciAqL1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3YmZmOyAvKiBEZWVwIGJsdWUgYmFja2dyb3VuZCAqL1xcbiAgICBjb2xvcjogI2ZmZjsgLyogV2hpdGUgdGV4dCBjb2xvciAqL1xcbiAgICBib3JkZXItcmFkaXVzOiA1MHB4OyAvKiBQaWxsIHNoYXBlICovXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBmb250LWZhbWlseTogUG9wcGlucywgc2Fucy1zZXJpZjtcXG4gICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcywgY29sb3IgMjAwbXMsIGJvcmRlci1jb2xvciAwLjNzO1xcbiAgICBib3gtc2hhZG93OiBibGFjayAtNHB4IDRweCAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSg0cHgsIC00cHgpO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW5cXG59XFxuXFxuLyogSG92ZXIgZWZmZWN0ICovXFxuYnV0dG9uOmhvdmVyIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMDAwOyAvKiBCbGFjayBib3JkZXIgb24gaG92ZXIgKi9cXG4gICAgY29sb3I6ICNmZmY7IC8qIFdoaXRlIHRleHQgY29sb3Igb24gaG92ZXIgKi9cXG4gICAgYm94LXNoYWRvdzogYmxhY2sgMHB4IDBweCAwO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwcHgsIDBweCk7XFxufVxcblxcbmltZyB7XFxuICAgIHdpZHRoOiAxNXB4O1xcbiAgICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi5jb250YWluZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDsgLyogRGlzdHJpYnV0ZSBzcGFjZSBldmVubHkgYmV0d2VlbiBjaGlsZHJlbiAqL1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyOyAvKiBDZW50ZXIgdmVydGljYWxseSBpZiBuZWVkZWQgKi9cXG4gICAgd2lkdGg6IDEwMCU7XFxufVwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHopO1xuXG52YXIgUHJvdmlkZXJzO1xuKGZ1bmN0aW9uIChQcm92aWRlcnMpIHtcbiAgICBQcm92aWRlcnNbXCJBUFBMRVwiXSA9IFwiQXBwbGUgSGVhbHRoXCI7XG4gICAgUHJvdmlkZXJzW1wiQ09OQ0VQVDJcIl0gPSBcIkNvbmNlcHQyXCI7XG4gICAgUHJvdmlkZXJzW1wiRUlHSFRcIl0gPSBcIkVpZ2h0XCI7XG4gICAgUHJvdmlkZXJzW1wiRklUQklUXCJdID0gXCJGaXRiaXRcIjtcbiAgICBQcm92aWRlcnNbXCJGUkVFU1RZTEVMSUJSRVwiXSA9IFwiRnJlZVN0eWxlTGlicmVcIjtcbiAgICBQcm92aWRlcnNbXCJHQVJNSU5cIl0gPSBcIkdhcm1pblwiO1xuICAgIFByb3ZpZGVyc1tcIkdPT0dMRVwiXSA9IFwiR29vZ2xlXCI7XG4gICAgUHJvdmlkZXJzW1wiSUZJVFwiXSA9IFwiSUZpdFwiO1xuICAgIFByb3ZpZGVyc1tcIk9VUkFcIl0gPSBcIk91cmFcIjtcbiAgICBQcm92aWRlcnNbXCJQRUxPVE9OXCJdID0gXCJQZWxvdG9uXCI7XG4gICAgUHJvdmlkZXJzW1wiUE9MQVJcIl0gPSBcIlBvbGFyXCI7XG4gICAgUHJvdmlkZXJzW1wiU0FNU1VOR1wiXSA9IFwiU2Ftc3VuZ1wiO1xuICAgIFByb3ZpZGVyc1tcIlNVVU5UT1wiXSA9IFwiU3V1bnRvXCI7XG4gICAgUHJvdmlkZXJzW1wiT01ST05cIl0gPSBcIk9tcm9uXCI7XG4gICAgUHJvdmlkZXJzW1wiQ09ST1NcIl0gPSBcIkNvcm9zXCI7XG4gICAgUHJvdmlkZXJzW1wiVEVNUE9cIl0gPSBcIlRlbXBvXCI7XG4gICAgUHJvdmlkZXJzW1wiVFJBSU5JTkdQRUFLU1wiXSA9IFwiVHJhaW5pbmdQZWFrc1wiO1xuICAgIFByb3ZpZGVyc1tcIldBSE9PXCJdID0gXCJXYWhvb1wiO1xuICAgIFByb3ZpZGVyc1tcIldIT09QXCJdID0gXCJXaG9vcFwiO1xuICAgIFByb3ZpZGVyc1tcIldFQVJPU1wiXSA9IFwiV2Vhck9TXCI7XG4gICAgUHJvdmlkZXJzW1wiV0lUSElOR1NcIl0gPSBcIldpdGhpbmdzXCI7XG4gICAgUHJvdmlkZXJzW1wiWldJRlRcIl0gPSBcIlp3aWZ0XCI7XG4gICAgUHJvdmlkZXJzW1wiRkFUU0VDUkVUXCJdID0gXCJGYXRTZWNyZXRcIjtcbiAgICBQcm92aWRlcnNbXCJDUk9OT01FVEVSXCJdID0gXCJDcm9ub21ldGVyXCI7XG4gICAgUHJvdmlkZXJzW1wiTVlGSVRORVNTUEFMXCJdID0gXCJNeUZpdG5lc3NQYWxcIjtcbiAgICBQcm92aWRlcnNbXCJOVVRSQUNIRUNLXCJdID0gXCJOdXRyYUNoZWNrXCI7XG4gICAgUHJvdmlkZXJzW1wiVU5ERVJBUk1PVVJcIl0gPSBcIlVuZGVyQXJtb3VyXCI7XG4gICAgUHJvdmlkZXJzW1wiR09PR0xFRklUXCJdID0gXCJHb29nbGVGaXRcIjtcbn0pKFByb3ZpZGVycyB8fCAoUHJvdmlkZXJzID0ge30pKTtcbmNvbnN0IGhlYWx0aERhdGFQcm92aWRlcnMgPSB7XG4gICAgJ0ZJVEJJVCc6IFByb3ZpZGVycy5GSVRCSVQsXG4gICAgJ0dBUk1JTic6IFByb3ZpZGVycy5HQVJNSU4sXG4gICAgJ0FQUExFJzogUHJvdmlkZXJzLkFQUExFLFxuICAgICdDT05DRVBUMic6IFByb3ZpZGVycy5DT05DRVBUMixcbiAgICAnRUlHSFQnOiBQcm92aWRlcnMuRUlHSFQsXG4gICAgJ0ZSRUVTVFlMRUxJQlJFJzogUHJvdmlkZXJzLkZSRUVTVFlMRUxJQlJFLFxuICAgICdHT09HTEUnOiBQcm92aWRlcnMuR09PR0xFLFxuICAgICdJRklUJzogUHJvdmlkZXJzLklGSVQsXG4gICAgJ09VUkEnOiBQcm92aWRlcnMuT1VSQSxcbiAgICAnUEVMT1RPTic6IFByb3ZpZGVycy5QRUxPVE9OLFxuICAgICdQT0xBUic6IFByb3ZpZGVycy5QT0xBUixcbiAgICAnU0FNU1VORyc6IFByb3ZpZGVycy5TQU1TVU5HLFxuICAgICdTVVVOVE8nOiBQcm92aWRlcnMuU1VVTlRPLFxuICAgICdPTVJPTic6IFByb3ZpZGVycy5PTVJPTixcbiAgICAnQ09ST1MnOiBQcm92aWRlcnMuQ09ST1MsXG4gICAgJ1RFTVBPJzogUHJvdmlkZXJzLlRFTVBPLFxuICAgICdUUkFJTklOR1BFQUtTJzogUHJvdmlkZXJzLlRSQUlOSU5HUEVBS1MsXG4gICAgJ1dBSE9PJzogUHJvdmlkZXJzLldBSE9PLFxuICAgICdXSE9PUCc6IFByb3ZpZGVycy5XSE9PUCxcbiAgICAnV0VBUk9TJzogUHJvdmlkZXJzLldFQVJPUyxcbiAgICAnV0lUSElOR1MnOiBQcm92aWRlcnMuV0lUSElOR1MsXG4gICAgJ1pXSUZUJzogUHJvdmlkZXJzLlpXSUZULFxuICAgICdGQVRTRUNSRVQnOiBQcm92aWRlcnMuRkFUU0VDUkVULFxuICAgICdDUk9OT01FVEVSJzogUHJvdmlkZXJzLkNST05PTUVURVIsXG4gICAgJ01ZRklUTkVTU1BBTCc6IFByb3ZpZGVycy5NWUZJVE5FU1NQQUwsXG4gICAgJ05VVFJBQ0hFQ0snOiBQcm92aWRlcnMuTlVUUkFDSEVDSyxcbiAgICAnVU5ERVJBUk1PVVInOiBQcm92aWRlcnMuVU5ERVJBUk1PVVIsXG4gICAgJ0dPT0dMRUZJVCc6IFByb3ZpZGVycy5HT09HTEVGSVRcbn07XG4vLyBjb25zdCBwcm92aWRlckljb25zOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge1xuLy8gICAgICdGSVRCSVQnOiBGaXRiaXRJY29uLFxuLy8gICAgICdHQVJNSU4nOiBHYXJtaW5JY29uLFxuLy8gICAgICdBUFBMRSc6IEFwcGxlSWNvbixcbi8vICAgICAnQ09OQ0VQVDInOiBDb25jZXB0Mkljb24sXG4vLyAgICAgJ0VJR0hUJzogRWlnaHRJY29uLFxuLy8gICAgICdGUkVFU1RZTEVMSUJSRSc6IEZyZWVTdHlsZUxpYnJlSWNvbixcbi8vICAgICAnR09PR0xFJzogR29vZ2xlSWNvbixcbi8vICAgICAnSUZJVCc6IElGaXRJY29uLFxuLy8gICAgICdPVVJBJzogT3VyYUljb24sXG4vLyAgICAgJ1BFTE9UT04nOiBQZWxvdG9uSWNvbixcbi8vICAgICAnUE9MQVInOiBQb2xhckljb24sXG4vLyAgICAgJ1NBTVNVTkcnOiBTYW1zdW5nSWNvbixcbi8vICAgICAnU1VVTlRPJzogU3V1bnRvSWNvbixcbi8vICAgICAnT01ST04nOiBPbXJvbkljb24sXG4vLyAgICAgJ0NPUk9TJzogQ29yb3NJY29uLFxuLy8gICAgICdURU1QTyc6IFRlbXBvSWNvbixcbi8vICAgICAnVFJBSU5JTkdQRUFLUyc6IFRyYWluaW5nUGVha3NJY29uLFxuLy8gICAgICdXQUhPTyc6IFdhaG9vSWNvbixcbi8vICAgICAnV0hPT1AnOiBXaG9vcEljb24sXG4vLyAgICAgJ1dJVEhJTkdTJzogV2l0aGluZ3NJY29uLFxuLy8gICAgICdaV0lGVCc6IFp3aWZ0SWNvbixcbi8vICAgICAnRkFUU0VDUkVUJzogRmF0U2VjcmV0SWNvbixcbi8vICAgICAnQ1JPTk9NRVRFUic6IENyb25vbWV0ZXJJY29uLFxuLy8gICAgICdNWUZJVE5FU1NQQUwnOiBNeUZpdG5lc3NQYWxJY29uLFxuLy8gICAgICdOVVRSQUNIRUNLJzogTnV0cmFDaGVja0ljb24sXG4vLyAgICAgJ1VOREVSQVJNT1VSJzogVW5kZXJBcm1vdXJJY29uLFxuLy8gfTtcbmNvbnN0IENvbm5lY3RUb1Byb3ZpZGVyQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gKF9hID0gcHJvcHMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHNlbGVjdGVkUHJvdmlkZXIgPSBwcm92aWRlciA/IGhlYWx0aERhdGFQcm92aWRlcnNbcHJvdmlkZXJdIDogbnVsbDtcbiAgICAvLyBjb25zdCBzZWxlY3RlZFByb3ZpZGVySWNvbiA9IHByb3ZpZGVyID8gcHJvdmlkZXJJY29uc1twcm92aWRlcl0gOiBudWxsO1xuICAgIHJldHVybiAocmVhY3RFeHBvcnRzLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgbnVsbCxcbiAgICAgICAgcmVhY3RFeHBvcnRzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdjb250YWluZXInIH0sXG4gICAgICAgICAgICByZWFjdEV4cG9ydHMuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgc2VsZWN0ZWRQcm92aWRlciA/IHNlbGVjdGVkUHJvdmlkZXIgOiAnX19fX18nKSkpKTtcbn07XG5cbmV4cG9ydHMuQ29ubmVjdFRvUHJvdmlkZXIgPSBDb25uZWN0VG9Qcm92aWRlckJ1dHRvbjtcbmV4cG9ydHMuQ29ubmVjdFRvVGVycmFCdXR0b24gPSBDb25uZWN0VG9UZXJyYUJ1dHRvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tryterra/terra-ui/dist/cjs/index.js\n");

/***/ })

};
;